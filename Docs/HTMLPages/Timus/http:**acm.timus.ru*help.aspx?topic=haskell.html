<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=utf-8"><META NAME="viewport" CONTENT="width=768"><META HTTP-EQUIV="X-UA-Compatible" CONTENT="IE=edge"><TITLE>How to write solutions on Haskell @ Timus Online Judge</TITLE><LINK REL="alternate" HREFLANG="x-default" HREF="/help.aspx?topic=haskell"><LINK REL="alternate" HREFLANG="en-us" HREF="/help.aspx?topic=haskell&amp;locale=en"><LINK REL="alternate" HREFLANG="ru-ru" HREF="/help.aspx?topic=haskell&amp;locale=ru"><LINK REL="stylesheet" TYPE="text/css" HREF="/style52.css"><LINK REL="shortcut icon" TYPE="image/x-icon" HREF="/favicon.ico"></HEAD><BODY><TABLE WIDTH="100%" CELLSPACING="0" CELLPADDING="0" CLASS="body"><TR><TD CLASS="caption"><TABLE WIDTH="100%" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="130" CLASS="locale"><A HREF="/help.aspx?topic=haskell&amp;locale=en">ENG</A>&nbsp;&nbsp;<A HREF="/help.aspx?topic=haskell&amp;locale=ru">RUS</A></TD><TD CLASS="title"><A HREF="/">Timus Online Judge</A></TD><TD WIDTH="130"></TD></TR></TABLE></TD></TR><TR><TD CLASS="panel"><TABLE WIDTH="100%" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="130" VALIGN="TOP" ALIGN="CENTER" STYLE="padding-bottom:5px;"><A HREF="/"><IMG BORDER="0" SRC="/images/usu-summer.jpg" HEIGHT="134" WIDTH="106" ALT=""></A></TD><TD VALIGN="TOP" ALIGN="LEFT"><TABLE WIDTH="100%" CELLSPACING="0" CELLPADDING="0" CLASS="panel"><TR><TH WIDTH="25%"><DIV>Online Judge</DIV></TH><TH WIDTH="25%"><DIV>Problems</DIV></TH><TH WIDTH="25%"><DIV>Authors</DIV></TH><TH WIDTH="25%"><DIV>Online contests</DIV></TH></TR><TR><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="/">About Online Judge</A><BR><A HREF="/help.aspx?topic=faq">Frequently asked questions</A><BR><A HREF="/news.aspx">Site news</A><BR><A HREF="/forum/">Webboard</A><BR><A HREF="/help.aspx?topic=links">Links</A><BR></TD><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="/problemset.aspx">Problem set</A><BR><A HREF="/submit.aspx">Submit solution</A><BR><A HREF="/status.aspx">Judge status</A><BR><A HREF="/help.aspx?topic=judge">Guide</A><BR></TD><TD VALIGN="TOP"><A HREF="/register.aspx">Register</A><BR><A HREF="/authedit.aspx">Update your info</A><BR><A HREF="/ranklist.aspx">Authors ranklist</A><BR><FORM ACTION="/search.aspx" METHOD="GET" STYLE="margin-top:0.6em;"><INPUT NAME="Str" SIZE="12" VALUE="" PLACEHOLDER="Author’s name"> <INPUT TYPE="SUBMIT" VALUE="Search"></FORM></TD><TD VALIGN="TOP"><A HREF="/contest.aspx">Current contest</A><BR><A HREF="/schedule.aspx">Scheduled contests</A><BR><A HREF="/archive.aspx">Past contests</A><BR><A HREF="/help.aspx?topic=contest">Rules</A><BR></TD></TR></TABLE></TD></TR></TABLE></TD></TR><TR><TD STYLE="padding-top: 32px; padding-bottom: 20px;"><STYLE>
			@import url(/prism.css);
		</STYLE><SCRIPT TYPE="text/javascript" SRC="/prism.js"></SCRIPT><TABLE ALIGN="CENTER" CELLSPACING="0" CELLPADDING="0"><TR><TD WIDTH="800"><H2 CLASS="title">How to write solutions on Haskell</H2><DIV ID="help_text"><P CLASS="help_par">Haskell programs are compiled on the server with <b>GHC 7.6.1</b>. The compiler is invoked with the following options:</P><PRE CLASS="with-background with-code"><CODE CLASS="language-none">ghc -v0 -O %1</CODE></PRE><P CLASS="help_par">You can find the compiler <A HREF="http://www.haskell.org/ghc/">here</A>.</P><H3 CLASS="subtitle">Example solutions</H3><P CLASS="help_par">The sample solution for the <A HREF="/problem.aspx?space=1&amp;num=1000">1000. A + B problem</A> in Haskell:</P><PRE CLASS="with-background with-code"><CODE CLASS="language-haskell">main = do
  [a, b] &lt;- (map read . words) `fmap` getLine
  print (a+b)
</CODE></PRE><P CLASS="help_par">You can also use the <code>sum</code> function:</P><PRE CLASS="with-background with-code"><CODE CLASS="language-haskell">main = interact $ show . sum . map read . words
</CODE></PRE><P CLASS="help_par">The sample solution for the <A HREF="/problem.aspx?space=1&amp;num=1001">1001. Reverse Root</A> in Haskell:</P><PRE CLASS="with-background with-code"><CODE CLASS="language-haskell">main = interact $ 
  unlines . reverse . map (show.sqrt.fromInteger.read) . words
</CODE></PRE><P CLASS="help_par">This solution hardly fits in the time limit constraint. Unfortunately, the standard Haskell <code>String</code> type is extremely inefficient. If you want to read or print a lot of numbers, as in this problem, you’ll have to use various tricks.</P><P CLASS="help_par">First of all, the module <code>Data.ByteString.Char8</code> contains the string type based on the array, not on the linked list of characters. Second, we should no longer use standard functions <code>read</code> and <code>show</code> for input/output. There is a function similar to <code>read</code>, but you’ll have to implement your own version of <code>show</code>.</P><PRE CLASS="with-background with-code"><CODE CLASS="language-haskell">import Data.List
import Data.Char
import Data.Maybe

import qualified Data.ByteString.Char8 as B</CODE></PRE><P CLASS="help_par">We will use  <code>readInteger</code> function to read the numbers.</P><PRE CLASS="with-background with-code"><CODE CLASS="language-haskell">readD :: B.ByteString -&gt; Double
readD = fromInteger . fst . fromJust . B.readInteger</CODE></PRE><P CLASS="help_par">We’ll have to print the number ourselves. Please note that <code>iPart</code> and <code>fPart</code> are of type <code>Integer</code>, it is faster than <code>Int64</code>.</P><PRE CLASS="with-background with-code"><CODE CLASS="language-haskell">showD :: Double -&gt; B.ByteString
showD n = B.pack $ show iPart ++ '.' : fDigs
  where
    (iPart, fPart) = quotRem (round (10000 * sqrt n)) 10000
    fDigs = let s = show fPart
            in  replicate (4 - length s) '0' ++ s</CODE></PRE><P CLASS="help_par">We are not able to print all the numbers at once because of the memory limit, so we’ll work with each number individually.</P><PRE CLASS="with-background with-code"><CODE CLASS="language-haskell">main = B.getContents &gt;&gt;=
  mapM_ (B.putStrLn.showD) . reverse . map readD . B.words</CODE></PRE><P CLASS="help_par">New solution works more than 10 times faster than the original version.</P><H3 CLASS="subtitle">Arrays</H3><P CLASS="help_par">We recommend you to use unboxed arrays (<code>UArray</code> in <code>Data.Array.Unboxed</code> and <code>STUArray</code> in <code>Data.Array.ST</code>), as they more efficient (up to several times).</P><P CLASS="help_par">If performance is still a problem, you can use functions <code>unsafeRead</code>, <code>unsafeWrite</code> and <code>unsafeAt</code> in <code>Data.Array.Base</code>. They drop array bounds checking and assume that array is indexed starting from 0.</P><H3 CLASS="subtitle">Map and Set</H3><P CLASS="help_par">If you use keys of type <code>Int</code> in Map or Set, consider using <code>Data.IntMap</code> or <code>Data.IntSet</code>, which are optimized for this frequent case.</P><H3 CLASS="subtitle">Laziness</H3><P CLASS="help_par">No expression in Haskell is evaluated until it’s needed. For example, you may print a first element of an infinite list. You can calculate 10 to the power of 1000000, and this would work as long as you don’t, for example, output this number.</P><P CLASS="help_par">The problem is that not yet calculated values (<em>thunks</em>) occupy much memory, and calculating them requires some "extra" time. For example, an expression</P><PRE CLASS="with-background with-code"><CODE CLASS="language-haskell">foldl (+) 0 [1..1000]</CODE></PRE><P CLASS="help_par">will, during its evaluation, expand into</P><PRE CLASS="with-background with-code"><CODE CLASS="language-none">(((...(0 + 1) + 2) + 3) + ... 999) + 1000</CODE></PRE><P CLASS="help_par">which may lead to stack overflow or unreasonable slowdown.</P><P CLASS="help_par">You can fight with lazy evaluation in three ways:</P><UL><LI CLASS="help_par">Use functions and data structures enforcing the evaluation (they are usually marked with the word <em>Strict</em> or a single quote character: <code>foldl'</code>, <code>Data.Map.Strict</code>, <code>UArray</code> etc.)</LI><LI CLASS="help_par">Bind the values with <code>seq</code>. <code>f (a `seq` b)</code> means that evaluating <code>b</code> will automatically enforce evaluation of <code>a</code>, if it won’t be needed later.</LI><LI CLASS="help_par">Exclamation. For example, function declaration <code>f !a = ...</code> is similar to <code>f a = a `seq` ...</code>.</LI></UL><H3 CLASS="subtitle">Some useful modules</H3><UL><LI CLASS="help_par"><a href="http://www.haskell.org/ghc/docs/7.6.1/html/libraries/base-4.6.0.0/Data-Complex.html">Data.Complex</a> — complex numbers.</LI><LI CLASS="help_par"><a href="http://www.haskell.org/ghc/docs/7.6.1/html/libraries/base-4.6.0.0/Data-Fixed.html">Data.Fixed</a> — fixed point numbers, and generalization of <code>div</code> and <code>mod</code> on real numbers.</LI><LI CLASS="help_par"><a href="http://www.haskell.org/ghc/docs/7.6.1/html/libraries/containers-0.5.0.0/Data-Sequence.html">Data.Sequence</a> — lists that support fast insertions to both ends, concatenation and random access.</LI><LI CLASS="help_par"><a href="http://www.haskell.org/ghc/docs/7.6.1/html/libraries/base-4.6.0.0/Text-Printf.html">Text.Printf</a> — implementation of <code>printf</code> from C.</LI><LI CLASS="help_par"><a href="http://www.haskell.org/ghc/docs/7.6.1/html/libraries/base-4.6.0.0/Text-ParserCombinators-ReadP.html">Text.ParserCombinators.ReadP</a> — convenient for creating parsers of complex grammars (also good for arithmetic expressions).</LI><LI CLASS="help_par"><a href="http://www.haskell.org/ghc/docs/7.6.1/html/libraries/base-4.6.0.0/GHC-Exts.html">GHC.Exts</a> — defines <code>groupWith</code> and <code>sortWith</code>. Now you can sort the strings in the order of increasing length like this: <code>sortWith length strings</code>.</LI></UL></DIV></TD></TR></TABLE></TD></TR><TR><TD CLASS="footer"><script type="text/javascript"> (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter20918869 = new Ya.Metrika({ id:20918869, clickmap:true, trackLinks:true, accurateTrackBounce:true }); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = "https://mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="https://mc.yandex.ru/watch/20918869" style="position:absolute; left:-9999px;" alt=""></div></noscript>© 2000–2017 <A HREF="/team.aspx">Timus Online Judge Team</A>. All rights reserved.</TD></TR></TABLE></BODY></HTML>