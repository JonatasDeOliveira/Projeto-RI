<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" />
<title>Segment tree - PEGWiki</title>
<meta name="generator" content="MediaWiki 1.25.2" />
<link rel="alternate" type="application/x-wiki" title="Edit" href="/wiki/index.php?title=Segment_tree&amp;action=edit" />
<link rel="edit" title="Edit" href="/wiki/index.php?title=Segment_tree&amp;action=edit" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/wiki/opensearch_desc.php" title="PEGWiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://wcipeg.com/wiki/api.php?action=rsd" />
<link rel="alternate" hreflang="x-default" href="/wiki/Segment_tree" />
<link rel="copyright" href="http://creativecommons.org/licenses/by/3.0/" />
<link rel="alternate" type="application/atom+xml" title="PEGWiki Atom feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=ext.math.styles%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wikidb:resourceloader:filter:minify-css:7:b36fd1c042133c9c9b60260f7c29b237 */</style>
<script src="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Segment_tree","wgTitle":"Segment tree","wgCurRevisionId":1970,"wgRevisionId":1970,"wgArticleId":60,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Data structures"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Segment_tree","wgRelevantArticleId":60,"wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});});
/* cache key: wikidb:resourceloader:filter:minify-js:7:a5c52c063dc436c1ca7c9f456936a5e9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/wiki/skins/Vector/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Segment_tree skin-vector action-view">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

						<div class="mw-indicators">
</div>
			<h1 id="firstHeading" class="firstHeading" lang="en">Segment tree</h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">From PEGWiki</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>The <b>segment tree</b> is a highly versatile <a href="/wiki/Data_structure" title="Data structure">data structure</a>, based upon the <a href="/wiki/Divide_and_conquer" title="Divide and conquer">divide-and-conquer</a> paradigm, which can be thought of as a tree of intervals of an underlying array, constructed so that queries on ranges of the array as well as modifications to the array's elements may be efficiently performed.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Motivation"><span class="tocnumber">1</span> <span class="toctext">Motivation</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#The_divide-and-conquer_solution"><span class="tocnumber">1.1</span> <span class="toctext">The divide-and-conquer solution</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-3"><a href="#Structure"><span class="tocnumber">2</span> <span class="toctext">Structure</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Operations"><span class="tocnumber">3</span> <span class="toctext">Operations</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Construction"><span class="tocnumber">3.1</span> <span class="toctext">Construction</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Update"><span class="tocnumber">3.2</span> <span class="toctext">Update</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Query"><span class="tocnumber">3.3</span> <span class="toctext">Query</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="#Analysis"><span class="tocnumber">4</span> <span class="toctext">Analysis</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Space"><span class="tocnumber">4.1</span> <span class="toctext">Space</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Time"><span class="tocnumber">4.2</span> <span class="toctext">Time</span></a>
<ul>
<li class="toclevel-3 tocsection-11"><a href="#Construction_2"><span class="tocnumber">4.2.1</span> <span class="toctext">Construction</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#Update_2"><span class="tocnumber">4.2.2</span> <span class="toctext">Update</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#Query_2"><span class="tocnumber">4.2.3</span> <span class="toctext">Query</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#Implementation"><span class="tocnumber">5</span> <span class="toctext">Implementation</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Variations"><span class="tocnumber">6</span> <span class="toctext">Variations</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="#Maximum"><span class="tocnumber">6.1</span> <span class="toctext">Maximum</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Sum_or_product"><span class="tocnumber">6.2</span> <span class="toctext">Sum or product</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Maximum.2Fminimum_prefix.2Fsuffix_sum"><span class="tocnumber">6.3</span> <span class="toctext">Maximum/minimum prefix/suffix sum</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Maximum.2Fminimum_subvector_sum"><span class="tocnumber">6.4</span> <span class="toctext">Maximum/minimum subvector sum</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#.22Stabbing_query.22"><span class="tocnumber">6.5</span> <span class="toctext">"Stabbing query"</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-21"><a href="#Extension_to_two_or_more_dimensions"><span class="tocnumber">7</span> <span class="toctext">Extension to two or more dimensions</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="#Lazy_propagation"><span class="tocnumber">8</span> <span class="toctext">Lazy propagation</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Motivation">Motivation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=1" title="Edit section: Motivation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>One of the most common applications of the segment tree is the solution to the <a href="/wiki/Range_minimum_query" title="Range minimum query">range minimum query</a> problem. In this problem, we are given some array and repeatedly asked to find the minimum value within some specified range of indices. For example, if we are given the array <img class="mwe-math-fallback-image-inline tex" alt="[9,2,6,3,1,5,0,7]" src="/wiki/images/math/a/3/e/a3e4109270a19cac82c7e91bec7564e4.png" />, we might be asked for the minimum element between the third and the sixth, inclusive, which would be <img class="mwe-math-fallback-image-inline tex" alt="\min(6,3,1,5) = 1" src="/wiki/images/math/5/6/1/5610fcfa93e7f22d902b0f85f7bf1440.png" />. Then, another query might ask for the minimum element between the first and third, inclusive, and we would answer 2, and so on. Various solutions to this problem are discussed in the <a href="/wiki/Range_minimum_query" title="Range minimum query">range minimum query</a> article, but the segment tree is often the most appropriate choice, especially when modification instructions are interspersed with the queries. For the sake of brevity, we shall focus for several following sections on the type of segment tree designed to answer the range minimum query without explicitly re-stating each time that we are doing so. Bear in mind, however, that other types of segment tree exist, which are discussed later in the article.
</p>
<h3><span class="mw-headline" id="The_divide-and-conquer_solution">The divide-and-conquer solution</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=2" title="Edit section: The divide-and-conquer solution">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The divide-and-conquer solution would be as follows:
</p>
<ul><li> If the range contains one element, that element itself is trivially the minimum within that range.</li>
<li> Otherwise, divide the range into two smaller ranges, each approximately half the size of the original, and find their respective minima. The minimum for the original range is then the smaller of the two minima of the sub-ranges.</li></ul>
<p>Hence, if <img class="mwe-math-fallback-image-inline tex" alt="a_i" src="/wiki/images/math/d/8/d/d8dd7d0f3eb7145ca41c711457b7eb8f.png" /> denotes the <img class="mwe-math-fallback-image-inline tex" alt="i" src="/wiki/images/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png" /><sup>th</sup> element in the array, finding the minimum could be encoded as the following recursive function:
</p>
<dl><dd><img class="mwe-math-fallback-image-inline tex" alt="\displaystyle&#10;f(x,y) =&#10;\begin{cases}&#10;a_x &amp; \mathrm{if\ } x = y \\&#10;\min(f(x,\lfloor\frac{x+y}{2}\rfloor),f(\lfloor\frac{x+y}{2}\rfloor+1,y)) &amp; \mathrm{otherwise} \\&#10;\end{cases}&#10;" src="/wiki/images/math/a/0/a/a0a67c008b2633ace15a16690fb94c40.png" /></dd></dl>
<p>assuming that <img class="mwe-math-fallback-image-inline tex" alt="x \le y" src="/wiki/images/math/0/4/9/0499fbc0b0f937d8f3a192a94edcd193.png" />.<br />
Hence, for example, the first query from the previous section would be <img class="mwe-math-fallback-image-inline tex" alt="f(3,6)" src="/wiki/images/math/6/2/1/621803a150e01d6f2371ac64fb0ce526.png" /> and it would be recursively evaluated as <img class="mwe-math-fallback-image-inline tex" alt="\min(f(3,4),f(5,6))" src="/wiki/images/math/a/9/5/a954287ea469b69b7d6eb7de49c4a01b.png" />.
</p>
<h2><span class="mw-headline" id="Structure">Structure</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=3" title="Edit section: Structure">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="/wiki/File:Segtree_92631507.png" class="image"><img alt="" src="/wiki/images/thumb/4/4f/Segtree_92631507.png/200px-Segtree_92631507.png" width="200" height="102" class="thumbimage" srcset="/wiki/images/thumb/4/4f/Segtree_92631507.png/300px-Segtree_92631507.png 1.5x, /wiki/images/4/4f/Segtree_92631507.png 2x" /></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Segtree_92631507.png" class="internal" title="Enlarge"></a></div>This segment tree.</div></div></div>
<p>Suppose that we use the function defined above to evaluate <img class="mwe-math-fallback-image-inline tex" alt="f(1,N)" src="/wiki/images/math/0/4/6/0463ae81b52608fb2cfb07855b1f7243.png" />, where <img class="mwe-math-fallback-image-inline tex" alt="N" src="/wiki/images/math/8/d/9/8d9c307cb7f3c4a32822a51922d1ceaa.png" /> is the number of elements in the array. When <img class="mwe-math-fallback-image-inline tex" alt="N" src="/wiki/images/math/8/d/9/8d9c307cb7f3c4a32822a51922d1ceaa.png" /> is large, this recursive call has two "children", one of which is the recursive call <img class="mwe-math-fallback-image-inline tex" alt="f\left(1,\left\lfloor\frac{N+1}{2}\right\rfloor\right)" src="/wiki/images/math/1/5/2/152daa8d8bc36d126b24491b2bacf2c4.png" />, and the other one of which is <img class="mwe-math-fallback-image-inline tex" alt="f\left(\left\lfloor\frac{N+1}{2}\right\rfloor+1,N\right)" src="/wiki/images/math/e/c/6/ec6a070a8caa27fc3f2fed910e6d8701.png" />. Each of these children will then have two children of its own, and so on, down until the base case is reached. If we represent these recursive calls with a tree structure, the call <img class="mwe-math-fallback-image-inline tex" alt="f(1,N)" src="/wiki/images/math/0/4/6/0463ae81b52608fb2cfb07855b1f7243.png" /> would be the root, it would have two children, each child would have two more children, and so on; the base cases would be the leaves of the tree. We are now ready to specify the structure of the segment tree:
</p>
<ul><li> it is a binary tree which represents some underlying array;</li>
<li> each node is associated with some interval of the array and contains the value(s) of one or more functions of the elements in that interval;</li>
<li> the root node is associated with the entire array (<i>i.e.</i> the interval <img class="mwe-math-fallback-image-inline tex" alt="[1,N]" src="/wiki/images/math/a/2/8/a287d2f128be5adc41f2ea0249d39045.png" />);</li>
<li> each leaf is associated with an individual element;</li>
<li> each non-leaf node has two children whose associated intervals are disjoint, and the union of the intervals associated with the two children is the interval associated with the parent;</li>
<li> each child's interval has approximately half the size of the parent's interval;</li>
<li> the data stored in each non-leaf node is not only a function of the elements in its associated interval but also a function of the data stored in its children.</li></ul>
<p>That is, the structure of the segment tree is exactly that of the recursive call tree of the function <img class="mwe-math-fallback-image-inline tex" alt="f(1,N)" src="/wiki/images/math/0/4/6/0463ae81b52608fb2cfb07855b1f7243.png" /> defined above (up to some minor details, such as whether the middle element of an interval of odd size belongs to the left child interval or the right).<br />
Hence, for example, the root node of the array <img class="mwe-math-fallback-image-inline tex" alt="[9,2,6,3,1,5,0,7]" src="/wiki/images/math/a/3/e/a3e4109270a19cac82c7e91bec7564e4.png" /> would contain the number 0: the minimum of the entire array. Its left child would contain the minimum of <img class="mwe-math-fallback-image-inline tex" alt="[9,2,6,3]" src="/wiki/images/math/8/4/b/84b2b8698c67105233fed595d56323d7.png" />, that is, 2, and the right would contain the minimum of <img class="mwe-math-fallback-image-inline tex" alt="[1,5,0,7]" src="/wiki/images/math/3/f/7/3f74c03e69ea78f1964137a87a0e88b2.png" />, that is, 0. Evidently, the datum stored in the root node, 0, is the minimum of the data stored at its immediate children, 0 and 2. Similarly, the datum 2 stored in the left child is the minimum of the data stored at <i>its</i> immediate children, 2 and 3 (which are the minima in <img class="mwe-math-fallback-image-inline tex" alt="[9,2]" src="/wiki/images/math/e/4/d/e4d830bf7280ee64ce69250c7fadb25c.png" /> and <img class="mwe-math-fallback-image-inline tex" alt="[6,3]" src="/wiki/images/math/f/9/1/f9141fbc368a52657b6060cddac6a108.png" />, respectively). Each individual element in the array has a leaf node, which merely contains that element itself. (The minimum of a range containing a single element is, of course, the element itself.)
</p>
<h2><span class="mw-headline" id="Operations">Operations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=4" title="Edit section: Operations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>There are three fundamental operations on a segment tree.
</p>
<h3><span class="mw-headline" id="Construction">Construction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=5" title="Edit section: Construction">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>To <i>construct</i> a segment tree is to initialize it so that it represents some array; we can query and modify this array later but first we need to construct a valid segment tree. We can construct a segment tree either top-down or bottom-up. Top-down construction is recursive; we attempt to fill in the root node, which leads to a recursive call on each of the two children, and so on; the base cases are the leaf nodes, which may be immediately filled in with the corresponding values from the array. After the two recursive calls made on behalf of a non-leaf node return, that node's value is set to the minimum of the values stored at the children. Bottom-up construction is left as an exercise for the reader; the difference in speed is likely to be negligible.
</p>
<h3><span class="mw-headline" id="Update">Update</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=6" title="Edit section: Update">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="/wiki/File:Segtree_92631587.png" class="image"><img alt="" src="/wiki/images/thumb/e/e0/Segtree_92631587.png/200px-Segtree_92631587.png" width="200" height="102" class="thumbimage" srcset="/wiki/images/thumb/e/e0/Segtree_92631587.png/300px-Segtree_92631587.png 1.5x, /wiki/images/e/e0/Segtree_92631587.png 2x" /></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Segtree_92631587.png" class="internal" title="Enlarge"></a></div>0 is changed to 8 in the segment tree above. Yellow nodes are those on the path from the root to the modified leaf; they are recursively traversed and their data are modified as the update occurs.</div></div></div>
<p>To <i>update</i> a segment tree is to modify the value of one element in the underlying array. To do so, we first modify the corresponding leaf node. The other leaf nodes are not affected, since each leaf node is associated only with an individual element. The modified node's parent is affected, since its associated interval contains the modified element, and so is the grandparent, and so on up to the root, but <b>no other nodes are affected</b>. To execute a top-down update, we begin by requesting an update of the root; this leads to a recursive call of <b>one</b> of the two children --- the one whose associated interval contains the modified element. (The other child and its subtree are unaffected.) The same is done recursively for the child; the base case is the leaf node associated with the element to update. After a recursive call has completed, the value in a non-leaf node is re-evaluated as the minimum of the values at its two children. Updating a segment tree bottom-up is possible too and is again left as an exercise for the reader.
</p>
<h3><span class="mw-headline" id="Query">Query</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=7" title="Edit section: Query">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="/wiki/File:Segtree_query_92631587.png" class="image"><img alt="" src="/wiki/images/thumb/c/cd/Segtree_query_92631587.png/200px-Segtree_query_92631587.png" width="200" height="102" class="thumbimage" srcset="/wiki/images/thumb/c/cd/Segtree_query_92631587.png/300px-Segtree_query_92631587.png 1.5x, /wiki/images/c/cd/Segtree_query_92631587.png 2x" /></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Segtree_query_92631587.png" class="internal" title="Enlarge"></a></div>Only the two nodes marked in yellow must be accessed to find the minimum of the elements corresponding to the leaves marked in grey.</div></div></div>
<p>To <i>query</i> a segment tree is to use it to determine a function of a range in the underlying array (in this case, the minimum element of that range). The execution of a query is more complex than the execution of an update and will be illustrated by example. Suppose we wish to know the minimum element between the first and sixth, inclusive. We shall represent this query as <img class="mwe-math-fallback-image-inline tex" alt="f(1,6)" src="/wiki/images/math/d/7/1/d7191f9aaa3389bf47690fe97fdaeadd.png" />. Each node in the segment tree contains the minimum in some interval: for example, the root node contains <img class="mwe-math-fallback-image-inline tex" alt="f(1,8)" src="/wiki/images/math/d/5/8/d58ca821d697b488505e035a972a98cb.png" />, its left child <img class="mwe-math-fallback-image-inline tex" alt="f(1,4)" src="/wiki/images/math/8/d/d/8dd65c30f735e7e098ca060c384585a6.png" />, its right <img class="mwe-math-fallback-image-inline tex" alt="f(5,8)" src="/wiki/images/math/0/d/f/0dfa9d38f26b06bf3020c243b9a27b3b.png" />, and so on, with each leaf containing <img class="mwe-math-fallback-image-inline tex" alt="f(x,x)" src="/wiki/images/math/6/d/2/6d28809bf76a5628bce3d51810301190.png" /> for some <img class="mwe-math-fallback-image-inline tex" alt="x" src="/wiki/images/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png" />. There is no node that contains <img class="mwe-math-fallback-image-inline tex" alt="f(1,6)" src="/wiki/images/math/d/7/1/d7191f9aaa3389bf47690fe97fdaeadd.png" />, but we notice that <img class="mwe-math-fallback-image-inline tex" alt="f(1,6) = \min(f(1,4),f(5,6))" src="/wiki/images/math/5/5/d/55d06a331d5deb48a36b06e163dc3f07.png" />, and that there <i>are</i> nodes in the segment tree containing those two values (shown in yellow). (This expression for <img class="mwe-math-fallback-image-inline tex" alt="f(1,6)" src="/wiki/images/math/d/7/1/d7191f9aaa3389bf47690fe97fdaeadd.png" /> is not the one given by the definition of <img class="mwe-math-fallback-image-inline tex" alt="f" src="/wiki/images/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png" />, but it is fairly clear that <img class="mwe-math-fallback-image-inline tex" alt="f(x,y) = \min(f(x,z),f(z+1,y))" src="/wiki/images/math/c/a/8/ca87846d9cd9ef2b84ae332c120e20b6.png" /> where <img class="mwe-math-fallback-image-inline tex" alt="x \le z &lt; y" src="/wiki/images/math/8/5/d/85dfefb1e0a10356b580125b858c16bf.png" />, regardless of the actual value of <img class="mwe-math-fallback-image-inline tex" alt="z" src="/wiki/images/math/f/b/a/fbade9e36a3f36d3d676c1b808451dd7.png" />.)<br />
When querying a segment tree, therefore, we select a subset of the nodes with the property that the union of their sets of descendants is exactly the interval whose minimum we seek. To do so, we start at the root and recurse over nodes whose corresponding intervals have at least one element in common with the query interval. Hence, in our example of <img class="mwe-math-fallback-image-inline tex" alt="f(1,6)" src="/wiki/images/math/d/7/1/d7191f9aaa3389bf47690fe97fdaeadd.png" />, we notice that both the left and right subtrees contain descendants that contain elements in the query interval; hence, we recurse on both. The left child of the root serves as a base case, since its interval is contained entirely within the query interval; hence it is chosen (marked in yellow). At the right child of the root, we notice that its left child has descendants in the query interval, but its right does not; hence we recurse on the former and not the latter. The former is now another base case, and it too is chosen and marked in yellow. The recursion has now terminated, and the desired minimum is the minimum of the nodes that have been chosen.
</p>
<h2><span class="mw-headline" id="Analysis">Analysis</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=8" title="Edit section: Analysis">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Some important performance bounds for segment trees are as follows:
</p>
<h3><span class="mw-headline" id="Space">Space</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=9" title="Edit section: Space">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A node whose depth is <img class="mwe-math-fallback-image-inline tex" alt="d" src="/wiki/images/math/8/2/7/8277e0910d750195b448797616e091ad.png" /> is associated with an interval of size no greater than <img class="mwe-math-fallback-image-inline tex" alt="\left\lceil{\frac{N}{2^d}}\right\rceil" src="/wiki/images/math/f/d/2/fd21f460af1f7afe2884c86b27125d3a.png" />. This is easily proven by induction on <img class="mwe-math-fallback-image-inline tex" alt="d" src="/wiki/images/math/8/2/7/8277e0910d750195b448797616e091ad.png" />. We therefore see that all nodes at depth <img class="mwe-math-fallback-image-inline tex" alt="\lceil\lg N \rceil" src="/wiki/images/math/6/7/3/67367c13fc021749a1c139c0e2012474.png" /> are responsible for no more than one element: they are leaves. Hence, a segment tree is a fully <b>balanced</b> binary tree; it has the minimum possible height for the number of nodes it contains. Because of this, we may store the tree as a <a href="/wiki/Breadth-first_search" title="Breadth-first search">breadth-first traversal</a> of its nodes, where the left child is (by convention) explored before the right. The segment tree above for <img class="mwe-math-fallback-image-inline tex" alt="[9,2,6,3,1,5,8,7]" src="/wiki/images/math/7/8/3/783ded2f93ad2c068f051d80eebc2b00.png" />, then, would be stored as <img class="mwe-math-fallback-image-inline tex" alt="[1,2,1,2,3,1,7,9,2,6,3,1,5,8,7]" src="/wiki/images/math/8/e/8/8e858673b6bd18ae3602d4dd13b6b847.png" />. Suppose the root is stored at index 1. Then, if a non-leaf node has index <img class="mwe-math-fallback-image-inline tex" alt="i" src="/wiki/images/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png" />, its left child will be stored at <img class="mwe-math-fallback-image-inline tex" alt="2i" src="/wiki/images/math/e/5/d/e5de2e95102b1ed31c3edbcd9701b6f0.png" /> and its right at <img class="mwe-math-fallback-image-inline tex" alt="2i+1" src="/wiki/images/math/a/1/7/a17022c3643548e48f666c66236fad49.png" />. Note that there will be some wasted space on the lowest level of the tree; this however is generally acceptable. A binary tree with a depth of <img class="mwe-math-fallback-image-inline tex" alt="\lceil\lg N\rceil" src="/wiki/images/math/6/7/3/67367c13fc021749a1c139c0e2012474.png" /> may have up to <img class="mwe-math-fallback-image-inline tex" alt="2^{\lceil\lg N\rceil + 1}-1" src="/wiki/images/math/2/0/2/202640230e4931d0d6a0b0179fff602f.png" /> elements, so some mathematical analysis shows that a segment tree on an array of <img class="mwe-math-fallback-image-inline tex" alt="N" src="/wiki/images/math/8/d/9/8d9c307cb7f3c4a32822a51922d1ceaa.png" /> elements requires an array of no more than <img class="mwe-math-fallback-image-inline tex" alt="4N" src="/wiki/images/math/b/9/3/b9396b5e36a071fc70a778ade10dc370.png" /> elements for its own storage in this manner. Asymptotically, a segment tree uses <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{O}(N)" src="/wiki/images/math/e/3/e/e3e85a10a3e7c2636dc7784f9f02f287.png" /> space.
</p>
<h3><span class="mw-headline" id="Time">Time</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=10" title="Edit section: Time">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span class="mw-headline" id="Construction_2">Construction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=11" title="Edit section: Construction">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Construction requires a constant number of operations on each node of the segment tree; as there are <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{O}(N)" src="/wiki/images/math/e/3/e/e3e85a10a3e7c2636dc7784f9f02f287.png" /> nodes, the construction takes linear time. You will notice that this is faster than doing <img class="mwe-math-fallback-image-inline tex" alt="N" src="/wiki/images/math/8/d/9/8d9c307cb7f3c4a32822a51922d1ceaa.png" /> separate update operations.
</p>
<h4><span class="mw-headline" id="Update_2">Update</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=12" title="Edit section: Update">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>A constant number of operations is performed for each node on the path from the root to the leaf associated with the modified element. The number of nodes on this path is bounded by the height of the tree; hence, <i>per</i> the conclusions in the Space section above, the time required for an update is <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{O}(\lg N)" src="/wiki/images/math/d/d/1/dd161db5b010882beec21d0300bfee36.png" />.
</p>
<h4><span class="mw-headline" id="Query_2">Query</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=13" title="Edit section: Query">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Consider the set of selected nodes (marked in yellow in the illustration). It is possible, in the case of a query <img class="mwe-math-fallback-image-inline tex" alt="f(1,N-1)" src="/wiki/images/math/1/5/f/15f28a8bf6f94fe61184903ffd917464.png" />, that there are logarithmically many. Can there be more? The answer is no. The simplest way of proving this, perhaps, is by exhibiting an algorithm for selecting the nodes that terminates within <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{O}(\lg N)" src="/wiki/images/math/d/d/1/dd161db5b010882beec21d0300bfee36.png" /> steps; this is the non-recursive algorithm alluded to earlier. So a query takes <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{O}(\lg N)" src="/wiki/images/math/d/d/1/dd161db5b010882beec21d0300bfee36.png" /> time. The proof that the recursive version also takes <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{O}(\lg N)" src="/wiki/images/math/d/d/1/dd161db5b010882beec21d0300bfee36.png" /> time is left as an exercise for the reader.
</p>
<h2><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=14" title="Edit section: Implementation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<pre>object rmq_segtree
     private function build_rec(node,begin,end,a[])
          if begin = end
               A[node] = a[begin];
          else
               let mid = floor((begin+end)/2)
               build_rec(2*node,begin,mid,a[])
               build_rec(2*node+1,mid+1,end,a[])
               A[node] = min(A[2*node],A[2*node+1])
     private function update_rec(node,begin,end,pos,val)
          if begin = end
               A[node] = val
          else
               let mid=floor((begin+end)/2)
               if pos&lt;=mid
                    update_rec(2*node,begin,mid,pos,val)
               else
                    update_rec(2*node+1,mid+1,end,pos,val)
               A[node] = min(A[2*node],A[2*node+1])
     private function query_rec(node,t_begin,t_end,a_begin,a_end)
          if t_begin&gt;=a_begin AND t_end&lt;=a_end
               return A[node]
          else
               let mid = floor((t_begin+t_end)/2)
               let res = ∞
               if mid&gt;=a_begin AND t_begin&lt;=a_end
                    res = min(res,query_rec(2*node,t_begin,mid,a_begin,a_end))
               if t_end&gt;=a_begin AND mid+1&lt;=a_end
                    res = min(res,query_rec(2*node+1,mid+1,t_end,a_begin,a_end))
               return res
     function construct(size,a[1..size])
          let N = size
          let A be an array that can hold at least 4N elements
          build_rec(1,1,N,a)
     function update(pos,val)
          update_rec(1,1,N,pos,val)
     function query(begin,end)
          return query_rec(1,1,N,begin,end)
</pre>
<h2><span class="mw-headline" id="Variations">Variations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=15" title="Edit section: Variations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The segment tree can be adapted to retrieve not only the minimum element in a range but also various other functions. Here are some examples taken from otherwise difficult contest problems:
</p>
<h3><span class="mw-headline" id="Maximum">Maximum</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=16" title="Edit section: Maximum">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Analogously to the minimum: all <code>min</code> operations replaced by <code>max</code>.
</p>
<h3><span class="mw-headline" id="Sum_or_product">Sum or product</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=17" title="Edit section: Sum or product">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Each non-leaf node contains the sum of the values at its children. For example, in the pseudocode above, all <code>min</code> operations would be replaced by addition operations. However, in the case of sums, the segment tree is superseded by the <a href="/wiki/index.php?title=Binary_indexed_tree&amp;action=edit&amp;redlink=1" class="new" title="Binary indexed tree (page does not exist)">binary indexed tree</a>, which is smaller (in terms of space), faster, and simpler to code. Product can be implemented in the same way, with multiplication in place of the addition.
</p>
<h3><span class="mw-headline" id="Maximum.2Fminimum_prefix.2Fsuffix_sum">Maximum/minimum prefix/suffix sum</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=18" title="Edit section: Maximum/minimum prefix/suffix sum">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A <i>prefix</i> of a range consists of the first <img class="mwe-math-fallback-image-inline tex" alt="k" src="/wiki/images/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png" /> elements in that range (<img class="mwe-math-fallback-image-inline tex" alt="k" src="/wiki/images/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png" /> may be zero); a <i>suffix</i> is analogously defined for the last <img class="mwe-math-fallback-image-inline tex" alt="k" src="/wiki/images/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png" /> elements. The <i>maximal sum prefix</i> of a range is the prefix with maximal sum (where the empty range has sum zero). That maximal sum is known as the <i>maximum prefix sum</i> (<i>minimum prefix sum</i> defined analogously). We would like to be able to query maximum prefix sum in an interval efficiently. For example, the maximum prefix sum in <img class="mwe-math-fallback-image-inline tex" alt="[1,-2,3,-4]" src="/wiki/images/math/5/3/7/5371e6626342ea4997b452ba8afc2e08.png" /> is 2, the sum of the prefix <img class="mwe-math-fallback-image-inline tex" alt="[1,-2,3]" src="/wiki/images/math/1/9/f/19f8e5f961d3fc33bbbc90e34ccdb0d4.png" />; no other prefix has a higher sum.</p>
<p>To solve this problem with a segment tree, we let each node store two functions of its associated interval: the maximum prefix sum and the total sum (of all elements in the interval). The total sum at a non-leaf node is the sum of the total sums at the two children. To find the max prefix sum at a non-leaf node, we notice that the maximal sum prefix ends either within the left child interval or within the right; in the former case, we simply take the maximal prefix sum from the left child, whereas in the latter we add the total sum from the left child and the maximal prefix sum from the right. The maximum of these two values then gives our answer. The query operation is similar, but with potentially more than two adjacent intervals (in which the optimal location for the end of the maximal sum prefix might lie in any one of them).</p>
<h3><span class="mw-headline" id="Maximum.2Fminimum_subvector_sum">Maximum/minimum subvector sum</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=19" title="Edit section: Maximum/minimum subvector sum">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This problem asks for the maximal sum of any sub-interval of a given interval. That is, it is similar to the max prefix sum problem explained in the previous section, but the beginning of the sub-interval is not anchored to the beginning of the given interval. (The maximal subvector sum in <img class="mwe-math-fallback-image-inline tex" alt="[1,-2,3,-4]" src="/wiki/images/math/5/3/7/5371e6626342ea4997b452ba8afc2e08.png" /> is 3, the sum of the sub-interval <img class="mwe-math-fallback-image-inline tex" alt="[3]" src="/wiki/images/math/f/2/5/f2577a6fc29b900fe7d4c6321346be48.png" />.) Each node now has to store four pieces of information about its associated interval: the max prefix sum, the max suffix sum, the max subvector sum, and the total sum. Details are left as an exercise for the reader.
</p>
<h3><span class="mw-headline" id=".22Stabbing_query.22">"Stabbing query"</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=20" title="Edit section: &quot;Stabbing query&quot;">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In this problem, the tree contains a dynamic set of intervals (that is, we may add or remove intervals) over a static set of endpoints (that is, we can only add intervals both of whose endpoints lie in a pre-determined set) lying on the one-dimensional number line. A query is the following question: <i>how many intervals in the set contain the following point?</i></p>
<p>To solve this problem, we first sort the endpoint set by coordinate (plus and minus infinity may be considered endpoints too, to simplify implementation details). The interval delimited by each pair of adjacent endpoints is assigned one leaf node in the segment tree, and a non-leaf node is associated with the union of the intervals at the children, as usual. When we add an interval to the tree, we increment the values (initially zero) stored at each of the nodes that would normally be selected if querying that interval (marked in yellow in the illustration); when we remove that interval, we decrement those values. To answer a query, we first locate (by <a href="/wiki/Binary_search" title="Binary search">binary search</a>) the leaf node whose interval contains the query point, and then we add the counts stored at all nodes on the path from that leaf to the root. (In some sense, then, the natures of the <i>query</i> and <i>update</i> operations are exchanged.)</p>
<p>Retrieving the intervals themselves is not difficult; the count field in each node is replaced by a list of intervals stored at that node; an update consists of adding/removing intervals to/from lists, rather than incrementing/decrementing counts, and the query consists of outputting the contents of all lists encountered on the way from the leaf to the root, rather than the sum of the counters.</p>
<h2><span class="mw-headline" id="Extension_to_two_or_more_dimensions">Extension to two or more dimensions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=21" title="Edit section: Extension to two or more dimensions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The segment tree data structure is not restricted to solving problems on one-dimensional arrays; in principle, it may be used on arrays of any dimension (time and space considerations, though, become more and more pressing in higher dimensions). Intervals are replaced by boxes. Hence, in a two-dimensional array, we might query the minimum element in a <i>box</i>, the Cartesian product of two intervals (for example, the set of vertices with row coordinate between 1 and 3, inclusive, and column coordinate between 2 and 5, inclusive).</p>
<p>For the two-dimensional segment tree, we start with a one-dimensional segment tree in which each leaf represents a row of the array and other nodes represent contiguous collections of rows. Now, each node is itself a one-dimensional segment tree, in which a leaf node represents the intersection of a single column with the row set, and other nodes represent larger boxes, still contained within the row set. For example, a segment tree on a 4&#215;4 array would have nodes for the row sets <img class="mwe-math-fallback-image-inline tex" alt="[1,4], [1,2], [3,4], [1,1], [2,2], [3,3], [4,4]" src="/wiki/images/math/e/b/2/eb2c51aca167c05487db646ab14075d3.png" />, exactly as for a one-dimensional segment tree. The node for <img class="mwe-math-fallback-image-inline tex" alt="[3,4]" src="/wiki/images/math/b/8/1/b814fa889082069ffb727ee1623c0944.png" />, for example, would itself be a tree on the boxes <img class="mwe-math-fallback-image-inline tex" alt="[3,4]\times[1,4], [3,4]\times[1,2], [3,4]\times[3,4], [3,4]\times[1,1], [3,4]\times[2,2], [3,4]\times[3,3], [3,4]\times[4,4]" src="/wiki/images/math/2/c/e/2ce0c71e3bdb36a7840abbe9d0e6ecae.png" />.</p>
<p>The application of higher-dimensional segment trees to geometrical problems is more complex and is discussed in a separate article.</p>
<h2><span class="mw-headline" id="Lazy_propagation">Lazy propagation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit&amp;section=22" title="Edit section: Lazy propagation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>For certain types of segment trees, <i>range updates</i> are possible. Consider, for example, a variation in the range minimum query problem in which we can not only update individual elements but also request that every element in a given range be set to the same specified value. This would be known as a <i>range update</i>. <i>Lazy propagation</i> is a technique that allows range updates to be carried out with the same asymptotic time complexity, <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{O}(\lg N)" src="/wiki/images/math/d/d/1/dd161db5b010882beec21d0300bfee36.png" />, as individual updates.</p>
<p>The technique works as follows: each node contains an additional <i>lazy</i> field, which will be used for temporary storage. When this field is not being used, its value will be set to <img class="mwe-math-fallback-image-inline tex" alt="+\infty" src="/wiki/images/math/2/8/c/28cfe0a2608499ff5984a938e0d16d64.png" />. When updating a range, we select the same set of nodes that we would select if querying that range, and update their lazy fields to the desired value (that is, we set them to the new value if the new value is lower), except for leaf nodes, whose values are immediately set to the new value. When a query or update operation requires us to access a proper descendant of any node whose <i>lazy</i> field is set (<i>i.e.</i> not <img class="mwe-math-fallback-image-inline tex" alt="+\infty" src="/wiki/images/math/2/8/c/28cfe0a2608499ff5984a938e0d16d64.png" />), we "push" the lazy field onto the two children: that is, we update the children's lazy fields according to the parent's and reset the parent's to <img class="mwe-math-fallback-image-inline tex" alt="+\infty" src="/wiki/images/math/2/8/c/28cfe0a2608499ff5984a938e0d16d64.png" />. If, however, we access the node without accessing any of its proper descendants, and the lazy field is set, we simply use the value of the lazy field as the minimum for that node's associated interval.</p>

<!-- 
NewPP limit report
CPU time usage: 0.124 seconds
Real time usage: 0.137 seconds
Preprocessor visited node count: 702/1000000
Preprocessor generated node count: 1512/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:60-0!*!0!!en!5!*!math=0 and timestamp 20180417105735 and revision id 1970
 -->
</div>									<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://wcipeg.com/wiki/index.php?title=Segment_tree&amp;oldid=1970">https://wcipeg.com/wiki/index.php?title=Segment_tree&amp;oldid=1970</a>"					</div>
													<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="/wiki/Category:Data_structures" title="Category:Data structures">Data structures</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-createaccount"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Segment+tree&amp;type=signup" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li><li id="pt-login"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Segment+tree" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
															<li  id="ca-nstab-main" class="selected"><span><a href="/wiki/Segment_tree"  title="View the content page [c]" accesskey="c">Page</a></span></li>
															<li  id="ca-talk" class="new"><span><a href="/wiki/index.php?title=Talk:Segment_tree&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a href="/wiki/Segment_tree" >Read</a></span></li>
															<li id="ca-edit"><span><a href="/wiki/index.php?title=Segment_tree&amp;action=edit"  title="You can edit this page. Please use the preview button before saving [e]" accesskey="e">Edit</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="/wiki/index.php?title=Segment_tree&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>

						<form action="/wiki/index.php" id="searchform">
														<div id="simpleSearch">
															<input type="search" name="search" placeholder="Search" title="Search PEGWiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />								</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="/wiki/Main_Page"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
			<h3 id='p-navigation-label'>Navigation</h3>

			<div class="body">
									<ul>
													<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
													<li id="n-Index"><a href="/wiki/Special:AllPages">Index</a></li>
													<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
													<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
													<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
			<h3 id='p-tb-label'>Tools</h3>

			<div class="body">
									<ul>
													<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Segment_tree" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
													<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Segment_tree" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
													<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
													<li id="t-print"><a href="/wiki/index.php?title=Segment_tree&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
													<li id="t-permalink"><a href="/wiki/index.php?title=Segment_tree&amp;oldid=1970" title="Permanent link to this revision of the page">Permanent link</a></li>
													<li id="t-info"><a href="/wiki/index.php?title=Segment_tree&amp;action=info" title="More information about this page">Page information</a></li>
											</ul>
							</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 6 April 2016, at 02:34.</li>
											<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by/3.0/">Attribution 3.0 Unported</a> unless otherwise noted.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="/wiki/PEGWiki:Privacy_policy" title="PEGWiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/wiki/PEGWiki:About" title="PEGWiki:About">About PEGWiki</a></li>
											<li id="footer-places-disclaimer"><a href="/wiki/PEGWiki:General_disclaimer" title="PEGWiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
															<a href="http://creativecommons.org/licenses/by/3.0/"><img src="http://i.creativecommons.org/l/by/3.0/88x31.png" alt="Attribution 3.0 Unported" width="88" height="31" /></a>
													</li>
											<li id="footer-poweredbyico">
															<a href="//www.mediawiki.org/"><img src="/wiki/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/wiki/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /wiki/resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" /></a>
													</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>if(window.jQuery)jQuery.ready();</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.toc","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"https://wcipeg.com/wiki/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=vector\u0026amp;*\"\u003E\u003C/script\u003E");
}</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":73});
}</script>
	</body>
</html>
