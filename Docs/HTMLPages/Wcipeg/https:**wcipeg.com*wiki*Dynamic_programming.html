<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" />
<title>Dynamic programming - PEGWiki</title>
<meta name="generator" content="MediaWiki 1.25.2" />
<link rel="alternate" type="application/x-wiki" title="Edit" href="/wiki/index.php?title=Dynamic_programming&amp;action=edit" />
<link rel="edit" title="Edit" href="/wiki/index.php?title=Dynamic_programming&amp;action=edit" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/wiki/opensearch_desc.php" title="PEGWiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://wcipeg.com/wiki/api.php?action=rsd" />
<link rel="alternate" hreflang="x-default" href="/wiki/Dynamic_programming" />
<link rel="copyright" href="http://creativecommons.org/licenses/by/3.0/" />
<link rel="alternate" type="application/atom+xml" title="PEGWiki Atom feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=ext.math.styles%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wikidb:resourceloader:filter:minify-css:7:b36fd1c042133c9c9b60260f7c29b237 */</style>
<script src="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Dynamic_programming","wgTitle":"Dynamic programming","wgCurRevisionId":1949,"wgRevisionId":1949,"wgArticleId":12,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Algorithms"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Dynamic_programming","wgRelevantArticleId":12,"wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});});
/* cache key: wikidb:resourceloader:filter:minify-js:7:a5c52c063dc436c1ca7c9f456936a5e9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/wiki/skins/Vector/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Dynamic_programming skin-vector action-view">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

						<div class="mw-indicators">
</div>
			<h1 id="firstHeading" class="firstHeading" lang="en">Dynamic programming</h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">From PEGWiki</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p><b>Dynamic programming</b> (DP) is a technique for solving problems that involves computing the solution to a large problem using previously-computed solutions to smaller problems. DP, however, differs from <a href="/wiki/Recursion" title="Recursion" class="mw-redirect">recursion</a> in that in DP, one solves the smallest possible subproblems (the base cases) <i>first</i>, and works <i>up</i> to the original problem, storing the solution to each subproblem in a table (usually a simple array or equivalent data structure) as it is computed so that its value can be quickly looked up when computing the solutions to larger subproblems. Most problems that are solved using DP are either <i>counting problems</i> or <i>optimization problems</i>, but there are others that fall into neither category. Because DP is a scheme for solving problems rather than a specific algorithm, its applicability is extremely broad, and so a number of examples are presented in this article to help explain exactly what DP is and what it can be used for.
</p><p>By some estimates, nearly a third of all problems that appear on the IOI and national olympiads and team selection competitions are intended to be solved using DP. This may have decreased in modern years, since competitors are getting better and better at solving DP problems. (The high incidence of DP problems on the Canadian Computing Competition, for one, will become evident in the examples below.)
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Basic_principles_of_DP"><span class="tocnumber">1</span> <span class="toctext">Basic principles of DP</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Optimal_substructure"><span class="tocnumber">1.1</span> <span class="toctext">Optimal substructure</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Overlapping_subproblems"><span class="tocnumber">1.2</span> <span class="toctext">Overlapping subproblems</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Example:_recursive_solution_to_Plentiful_Paths"><span class="tocnumber">1.3</span> <span class="toctext">Example: recursive solution to Plentiful Paths</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Example:_dynamic_solution_to_Plentiful_Paths"><span class="tocnumber">1.4</span> <span class="toctext">Example: dynamic solution to Plentiful Paths</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Optimization_example:_Change_problem"><span class="tocnumber">2</span> <span class="toctext">Optimization example: Change problem</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Counting_example:_Keep_on_Truckin.27"><span class="tocnumber">3</span> <span class="toctext">Counting example: Keep on Truckin'</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Disjoint_and_exhaustive_substructure"><span class="tocnumber">3.1</span> <span class="toctext">Disjoint and exhaustive substructure</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Example"><span class="tocnumber">3.2</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Pseudocode_implementation"><span class="tocnumber">3.3</span> <span class="toctext">Pseudocode implementation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#Paths_in_a_DAG"><span class="tocnumber">4</span> <span class="toctext">Paths in a DAG</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#Example_problem:_Water_Park"><span class="tocnumber">4.1</span> <span class="toctext">Example problem: Water Park</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Example_2"><span class="tocnumber">4.2</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Generalization"><span class="tocnumber">4.3</span> <span class="toctext">Generalization</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#State_and_dimension"><span class="tocnumber">4.4</span> <span class="toctext">State and dimension</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Basic_principles_of_DP">Basic principles of DP</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=1" title="Edit section: Basic principles of DP">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Not every optimization problem can be solved using DP, just as not every optimization problem can be solved using recursion. In order for an optimization problem to be solvable using DP, it must have the property of <i>optimal substructure</i>. And most of the time, when DP is useful, the problem will exhibit <i>overlapping subproblems</i>. (We can solve problems using DP even when they do not exhibit overlapping subproblems; but such problems can also easily be solved using naive recursive methods.) We will examine the problem <a rel="nofollow" class="external text" href="http://wcipeg.com/problem/wc96p5">Plentiful Paths</a> from the 1996 Woburn Challenge and show how it exhibits both properties.
</p>
<h3><span class="mw-headline" id="Optimal_substructure">Optimal substructure</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=2" title="Edit section: Optimal substructure">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>An optimization problem is said to have <i>optimal substructure</i> when it can be broken down into subproblems and the optimal solution to the original problem can be computed from the optimal solutions of the subproblems. Another way of saying this is that the optimal solution to a large problem contains an optimal solution (sometimes more than one) for a subproblem (maybe more than one). This is often stated and proved in its contrapositive form, which is that if a solution to a problem instance contains any suboptimal solutions to subinstances, then the solution is not optimal for the original instance. Let's put this into the context of Plentiful Paths.
</p><p>The Plentiful Paths problem asks us to <i>optimize</i> the number of apples collected in travelling from the lower-left square to the upper-right square. We start at (1,1) and end up eventually at (<i>M</i>,<i>N</i>). It is fairly clear that at some point we must pass through either (<i>M</i>-1,<i>N</i>) <i>or</i> (<i>M</i>,<i>N</i>-1). (Think about this carefully if you don't see why this is.) Suppose that the optimal solution involved travelling through (<i>M</i>-1,<i>N</i>). So we take some path to reach (<i>M</i>-1,<i>N</i>) and then we take one step to reach the end, (<i>M</i>,<i>N</i>). A bit of thought should convince you that we must collect as many apples as possible on the path from (1,1) to (<i>M</i>-1,<i>N</i>) if we want to collect the maximum possible number of apples on the path from (1,1) to (<i>M</i>,<i>N</i>). This is because if we found a better path to get to (<i>M</i>-1,<i>N</i>) - that is, one with more apples along the way - then we would also collect more apples in total getting to (<i>M</i>,<i>N</i>).
</p><p>Having said that, the optimal path to (<i>M</i>-1,<i>N</i>) must itself consist of an optimal path to one of the squares immediately before it, for the same reason: either (<i>M</i>-2,<i>N</i>) or (<i>M</i>-1,<i>N</i>-1)... and so on.
</p><p>(Notice that if A is a subproblem of B, and B is a subproblem of C, then A is a subproblem of C as well. Then, a DP solution would first solve A, then use this to solve B, and finally use that to solve C. But if A is a subproblem of B, B <i>cannot</i> be a subproblem of A. This is because, in order to find an optimal solution to B, we would first need an optimal solution to A, but to find an optimal solution to A, we would first need an optimal solution to B, so ultimately we can solve neither problem.)
</p><p>The Plentiful Paths problem has optimal substructure because any optimal solution to an instance of Plentiful Paths contains an optimal solution to a subproblem. In general, in a DP solution, we start by solving the smallest possible subproblems (such as: "how many apples can we collect going from (1,1) to (1,1)?") and work our way up to larger problems.
</p>
<h3><span class="mw-headline" id="Overlapping_subproblems">Overlapping subproblems</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=3" title="Edit section: Overlapping subproblems">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A problem is said to have <i>overlapping subproblems</i> when some of its subproblems are repeated. For example, in Plentiful Paths, in order to find an optimal path to (M,N), we must find the optimal paths to (M-1,N) and (M,N-1). To find the optimal path to (M-1,N), we need to find the optimal paths to both (M-2,N) and (M-1,N-1); to find the optimal path to (M,N-1) we must find the optimal path to both (M-1,N-1) and (M,N-2). Notice that the subproblem (M-1,N-1) was repeated. It is the fact that subproblems are repeated that gives DP its massive efficiency advantage over the recursive solution in the next section.
</p>
<h3><span class="mw-headline" id="Example:_recursive_solution_to_Plentiful_Paths">Example: recursive solution to Plentiful Paths</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=4" title="Edit section: Example: recursive solution to Plentiful Paths">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Based on the optimal substructure property of the Plentiful Paths problem, we might write the following pseudocode:
</p>
<pre>function plentiful_paths(A,x,y)
     if x=1
          if y=1 then
               return A[x,y]
          else
               return A[x,y]+plentiful_paths(A,x,y-1)
     else
          if y=1 then
               return A[x,y]+plentiful_paths(A,x-1,y)
          else
               return A[x,y]+max(plentiful_paths(A,x-1,y),plentiful_paths(A,x,y-1))
input M,N,A
print plentiful_paths(A,M,N)
</pre>
<p>Here, A is a matrix (two-dimensional array) in which an entry is 1 if the corresponding position in the grid contains an apple and 0 if it does not contain an apple; the function plentiful_paths(A,x,y) returns the maximum number of apples that can be retrieved in going from (1,1) to (x,y) in grid A.
</p>
<ul><li> If x and y are both 1, then the question is how many apples we can collect if we travel from (1,1) to (1,1); this will simply be 1 if there is an apple at (1,1) and 0 otherwise. (That is the quantity A[x,y].)</li>
<li> If x is 1 but y is not, then in order to travel from (1,1) to (x,y), we must first travel from (1,1) to (x,y-1), then take one step to reach (x,y). The maximum number of apples we can collect in travelling to (x,y) is equal to the maximum number of apples we can collect in travelling to (x,y-1) (this is plentiful_paths(A,x,y-1)), <i>plus</i> one if there is an apple at (x,y).</li>
<li> Similarly, if x is not 1 and y is 1, then we collect the maximum number of apples in travelling to (x-1,y), then we add one apple if there is an apple in the square (x,y).<br /></li></ul>
<p>If x and y are both greater than 1, then the optimal path to (x,y) goes through either (x-1,y) or (x,y-1). The maximum number of apples collected in reaching (x,y) will be either the maximum number of apples collected in reaching (x-1,y) or the same for (x,y-1), <i>whichever is greater</i> (that is to say, <i>max(plentiful_paths(A,x-1,y),plentiful_paths(A,x,y-1))</i>), <i>plus</i> one if there is an apple at (x,y).
</p><p>The problem with this recursive solution is that, even though the value of plentiful_paths(A,i,j) will be the same every time it is calculated as long as A, i, and j stay the same, it might calculate that value hundreds of times. For example, in calculating plentiful_paths(A,5,5), we will actually calculate plentiful_paths(A,1,1) seventy times. This is because of the overlapping subproblems. For larger grids, we waste so much time recalculating values that the algorithm becomes impractically slow and therefore unusable. We can avoid this by using <a href="/wiki/Memoization" title="Memoization">memoization</a>. However, DP presents an alternative solution.
</p><p>(Note that in a real recursive solution we would not pass A by value, since its value never changes and thus passing by value would slow down the solution massively by copying A over and over again. Instead, A would be either passed by reference or stored as a global variable. In the latter case, it would disappear from the parameter list altogether.)
</p>
<h3><span class="mw-headline" id="Example:_dynamic_solution_to_Plentiful_Paths">Example: dynamic solution to Plentiful Paths</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=5" title="Edit section: Example: dynamic solution to Plentiful Paths">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<pre>input M,N,A
for x = 1 to M
     for y = 1 to N
          if x=1 then
               if y=1 then
                    dp[x,y]=A[x,y]
               else
                    dp[x,y]=A[x,y]+dp[x,y-1]
          else
               if y=1 then
                    dp[x,y]=A[x,y]+dp[x-1,y]
               else
                    dp[x,y]=A[x,y]+max(dp[x-1,y],dp[x,y-1])
print dp[M,N]
</pre>
<p>In the dynamic solution, dp[x,y] represents the maximum possible number of apples that can be obtained on some path from (1,1) to (x,y). As soon as we calculate this value, we store it in the two-dimensional array dp[]. We see that this solution follows essentially the same logic as the recursive solution, and our final answer is dp[M,N]. However, <i>no entry in the dp[] table is calculated more than once.</i> When M and N are each 1000, it would take far longer than the age of the universe for the recursive solution to finish executing even if the entire surface of the Earth were covered in transistors being used exclusively to execute the algorithm, but the dynamic solution would run in under a second on a modern desktop computer.
</p><p>This solution exemplifies both the optimal substructure property (because in calculating dp[x,y], an optimal solution for the square (x,y) we potentially examine the values of dp[x-1,y] and dp[x,y-1], optimal solutions for possible preceding squares, or subproblems) and the overlapping subproblems property (most entries in the dp[] table will be examined twice, but only calculated once). It is the presence of overlapping subproblems that gives DP such a huge efficiency advantage over the naive recursive solution: we will only calculate the solution to each subproblem once, and from then on we will look it up whenever it is needed. Finally, we have computed the solution <i>bottom-up</i>, by solving the smallest subproblems first so that by the time we reach a particular subproblem, we have already computed the solutions to any subproblems on which that subproblem depends. Contrast this with the recursive solution, which considers the largest subproblem (the original problem) first; it is <i>top-down</i>.
</p>
<h2><span class="mw-headline" id="Optimization_example:_Change_problem">Optimization example: Change problem</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=6" title="Edit section: Optimization example: Change problem">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><i>Dynamic change</i> is the name given to a well-known algorithm for determining how to make change for a given amount of money using the fewest possible coins, assuming that we have an unlimited supply of coins of every denomination. For example, if the available denominations are 1 cent, 5 cents, 10 cents, and 25 cents, then we can make change for 48 cents by using one 25-cent coin, one 10-cent coins, two 5-cent,and three 1-cent coins, that is, 7 coins in total. There are other ways to make change for the same amount (for example, four 10-cent coins and eight 1-cent coins), but they all use 12 coins. Other sets of denominations are not so easy; for example, suppose we have at our disposal 17-cent, 14-cent, 9-cent, and 7-cent coins. It is now not immediately obvious how best to make change for a dollar (The solution is to use four 17-cent coins, one 14-cent coin, and two 9-cent coins.) Nor is it immediately obvious that it is impossible to make change for 29 cents.
</p><p>The problem <a rel="nofollow" class="external text" href="http://wcipeg.com/problem/ccc00s4">Golf</a> from the 2000 Canadian Computing Competition is exactly analogous. Here, the distance to the hole is the amount for which we wish to make change, and each golf club is a denomination with value equal to how far it will hit the golf ball.
</p><p>The general form of this problem is: given <img class="mwe-math-fallback-image-inline tex" alt="n \in \mathbb{N}_0, d_1, d_2, ..., d_m \in \mathbb{N}_1" src="/wiki/images/math/7/4/c/74c15132d64bab0e6cc91b6d173074eb.png" />, find <img class="mwe-math-fallback-image-inline tex" alt="a_1, a_2, ..., a_m \in \mathbb{N}_0" src="/wiki/images/math/3/a/e/3ae9562a21742021ecc368bb0625bf66.png" /> such that <img class="mwe-math-fallback-image-inline tex" alt="a_1 d_1 + a_2 d_2 + ... + a_n d_n = n" src="/wiki/images/math/6/3/5/6352a40d72012a5c7681abe1f6fcbdbe.png" /> and <img class="mwe-math-fallback-image-inline tex" alt="a_1 + a_2 + ... + a_m" src="/wiki/images/math/e/c/e/ece11ca8a454a3cdf9301eb03fde2d34.png" /> is minimal. <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" /> corresponds to the amount we wish to change, each <img class="mwe-math-fallback-image-inline tex" alt="d_i" src="/wiki/images/math/3/5/b/35b35a527030cca017dbc36fcd8a0387.png" /> to a denomination, and each <img class="mwe-math-fallback-image-inline tex" alt="a_i" src="/wiki/images/math/d/8/d/d8dd7d0f3eb7145ca41c711457b7eb8f.png" /> to the number of coins of a given denomination we wish to use.
</p><p>This problem exhibits optimal substructure in the following sense. Suppose we have found out how to make change for <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" /> cents using some minimal collection of coins, and we take one coin away (with value <img class="mwe-math-fallback-image-inline tex" alt="x" src="/wiki/images/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png" />), leaving a collection of coins with total value <img class="mwe-math-fallback-image-inline tex" alt="n-x" src="/wiki/images/math/0/a/6/0a60891d81e36a701c40fbb0823bae2e.png" />. Then, what we are left with <i>must</i> be an optimal way to make change for <img class="mwe-math-fallback-image-inline tex" alt="n-x" src="/wiki/images/math/0/a/6/0a60891d81e36a701c40fbb0823bae2e.png" />. This is because if we had any <i>better</i> way (fewer coins) of making change for <img class="mwe-math-fallback-image-inline tex" alt="n-x" src="/wiki/images/math/0/a/6/0a60891d81e36a701c40fbb0823bae2e.png" />, then we could just add the coin of value <img class="mwe-math-fallback-image-inline tex" alt="x" src="/wiki/images/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png" /> back in, and get a better way of making change for <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" /> cents than what we originally assumed was minimal, a contradiction.
</p><p>For example, if we have 48 cents in the form of one 25-cent coin, one 10-cent coins, two 5-cent coins, and three 1-cent coins, and we take away the 25-cent coin, then we are left with one 10-cent coins, two 5-cent coins, and three 1-cent coins, that is, 6 coins totalling 23 cents. However, 7 coins is not the least number of coins required to change 23 cents; we could do it in 5 (using two 10-cent coins and three 1-cent coins). This proves that our original way of making change for 48 cents was not optimal, as we can just add the quarter back in (so we'll have one 25-cent coin, two 10-cent coins, and three 1-cent coins, or 6 coins totalling 48 cents) and get a better way. Whenever we have a suboptimal solution to a subinstance, we will also have a suboptimal solution to the original instance; so an optimal solution to the original instance is only allowed to contain optimal solutions to subinstances.
</p><p>To solve the change problem using DP, we start by considering the simplest possible case: when the amount to be changed is zero. Then, the optimal (and only) solution is to use no coins at all. But whenever we change a positive amount, we must use at least one coin. If we take any coin (with value <img class="mwe-math-fallback-image-inline tex" alt="x" src="/wiki/images/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png" />) away from the optimal change for amount <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" />, then we are left with optimal change for <img class="mwe-math-fallback-image-inline tex" alt="n-x" src="/wiki/images/math/0/a/6/0a60891d81e36a701c40fbb0823bae2e.png" />. This implies that we can make optimal change for <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" /> using at least one of the following ways: make optimal change for <img class="mwe-math-fallback-image-inline tex" alt="n-d_1" src="/wiki/images/math/4/3/4/43427fe7f07d4393f60716ecf5522685.png" /> and add one coin of value <img class="mwe-math-fallback-image-inline tex" alt="d_1" src="/wiki/images/math/9/7/5/975e82ee46300a50d901d66c00fe64b1.png" />; or make optimal change for <img class="mwe-math-fallback-image-inline tex" alt="n-d_2" src="/wiki/images/math/a/e/1/ae14994ddea2b3f6c7afe126e2ce80a1.png" /> and add one coin of value <img class="mwe-math-fallback-image-inline tex" alt="d_2" src="/wiki/images/math/2/6/e/26ee688d727ea0c771dbdf3f456895bd.png" />; ...; or make optimal change for <img class="mwe-math-fallback-image-inline tex" alt="n-d_m" src="/wiki/images/math/c/e/d/ced10fd36cddc234492759e22f14ba54.png" /> and add one coin of value <img class="mwe-math-fallback-image-inline tex" alt="d_m" src="/wiki/images/math/3/f/5/3f5ddb968cbc448e267b9e2092c05265.png" />. This is because if <i>none</i> of these are optimal, then when we make optimal change for <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" />, and remove some coin of value <img class="mwe-math-fallback-image-inline tex" alt="d_i" src="/wiki/images/math/3/5/b/35b35a527030cca017dbc36fcd8a0387.png" />, leaving <img class="mwe-math-fallback-image-inline tex" alt="n-d_i" src="/wiki/images/math/e/d/2/ed2ddbab1b98fdb9597b68abfadf7962.png" />, we will have optimal change for <img class="mwe-math-fallback-image-inline tex" alt="n-d_i" src="/wiki/images/math/e/d/2/ed2ddbab1b98fdb9597b68abfadf7962.png" />, but we already know that adding a coin of value <img class="mwe-math-fallback-image-inline tex" alt="d_i" src="/wiki/images/math/3/5/b/35b35a527030cca017dbc36fcd8a0387.png" /> to the leftover collection does <i>not</i> give optimal change for <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" />, and yet it regenerates the original collection, which we assumed to be optimal, and this is a contradiction.
</p><p>We conclude that to make optimal change for <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" />, we consider all denominations with <img class="mwe-math-fallback-image-inline tex" alt="d_i \leq n" src="/wiki/images/math/9/5/f/95f246a78e9809886e39c85617834c50.png" />; for each of these, we figure out how many coins are required to make change for <img class="mwe-math-fallback-image-inline tex" alt="n-d_i" src="/wiki/images/math/e/d/2/ed2ddbab1b98fdb9597b68abfadf7962.png" />, and then add one to make change for <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" />; and after considering all these possibilities, the one that uses the fewest total coins is the optimal way to make change for <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" /> coins. (Note that if <img class="mwe-math-fallback-image-inline tex" alt="d_i &gt; n" src="/wiki/images/math/9/e/8/9e855c1f088d557536066965d1635221.png" />, then there is simply no way that any way of making change for <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" /> will use the coin with value <img class="mwe-math-fallback-image-inline tex" alt="d_i" src="/wiki/images/math/3/5/b/35b35a527030cca017dbc36fcd8a0387.png" /> at all, so we don't even need to consider it.)
</p><p>Also, if it is not possible to make change for <img class="mwe-math-fallback-image-inline tex" alt="n - d_i" src="/wiki/images/math/e/d/2/ed2ddbab1b98fdb9597b68abfadf7962.png" /> no matter what <img class="mwe-math-fallback-image-inline tex" alt="i" src="/wiki/images/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png" /> is (in other words, subtracting any denomination is guaranteed to give something unchangeable), then we can give up; there is clearly no way to make change for <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" /> either.
</p><p>Pseudocode (prints either the minimum number of coins required to make change, or concludes that it is impossible):
</p>
<pre>input n, m, array d
c[0] &#8592; 0    // can make change for 0 using 0 coins
for i &#8712; [1..n]
    c[i] &#8592; &#8734;
    for j &#8712; [1..m]
        if d[j] &#8804; i
            c[i] &#8592; min(c[i], c[i-d[j]]+1)
if c[n] = &#8734;
    print Impossible
else
    print c[n]
</pre>
<p>Note that this implementation gives us the minimum number of coins, but does not actually produce a minimal combination of coins that adds to the target amount. Should you wish to accomplish this, however, there is a simple solution that demonstrates a recurring technique in optimization dynamic programming:
</p>
<pre>input n, m, array d
c[0] &#8592; 0    // can make change for 0 using 0 coins
for i &#8712; [1..n]
    c[i] &#8592; &#8734;
    for j &#8712; [1..m]
        if d[j] &#8804; i
            if c[i-d[j]]+1 &lt; c[i]
                c[i] &#8592; c[i-d[j]]+1
                l[i] &#8592; j
if c[n] = &#8734;
    print Impossible
else
    while n &gt; 0
        print l[n]
        n &#8592; n - d[l[n]]
</pre>
<p>In the algorithm's inner loop, we try every possible denomination <code>j</code> to see whether we can use it to improve the current best estimate of the cost of making change for amount <code>i</code>. We also record the denomination we actually chose, using the array <code>l</code>. This tells us that we can make optimal change for <code>i</code> by using a coin of denomination <code>j</code> and then making optimal change for what remains. In the output loop, then, we repeatedly print out a denomination that works, and then subtract it off, until we are left with zero, meaning the entire amount has been optimally changed.
</p>
<h2><span class="mw-headline" id="Counting_example:_Keep_on_Truckin.27">Counting example: Keep on Truckin'</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=7" title="Edit section: Counting example: Keep on Truckin'">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The problem <a rel="nofollow" class="external text" href="http://wcipeg.com/problem/ccc07j5">Keep on Truckin'</a> from the 2007 Canadian Computing Competition is easily expressible in an abstract form. A number of points are marked on a horizontal line, with x-coordinates <img class="mwe-math-fallback-image-inline tex" alt="0 = x_0 &lt; x_1 &lt; x_2 &lt; ... &lt; x_n" src="/wiki/images/math/3/f/3/3f3d6b55b9ab1c05b2148f01f505e776.png" />. We start out at the leftmost point and we wish to reach the rightmost point. To do so, we take a sequence of steps. In each step, we walk from our current point to some point to our right. The length of a step must be at least <img class="mwe-math-fallback-image-inline tex" alt="A" src="/wiki/images/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png" />, but not more than <img class="mwe-math-fallback-image-inline tex" alt="B" src="/wiki/images/math/9/d/5/9d5ed678fe57bcca610140957afab571.png" />. We wish to know in how many different ways we can complete the trip. Two ways of completing the trip are considered different if one of them visits a point that the other does not.
</p>
<h3><span class="mw-headline" id="Disjoint_and_exhaustive_substructure">Disjoint and exhaustive substructure</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=8" title="Edit section: Disjoint and exhaustive substructure">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This problem is a counting problem, not an optimization problem. Counting problems cannot exhibit optimal substructure, because they are not optimization problems. Instead, the kinds of counting problems that are amenable to DP solutions exhibit a different kind of substructure, which we shall term <i>disjoint and exhaustive substructure</i>. (Counting problems do, however, often exhibit overlapping subproblems, just like optimization problems.)
</p><p>In this particular problem, to count the number of ways to get from <img class="mwe-math-fallback-image-inline tex" alt="x_0" src="/wiki/images/math/0/b/2/0b21a666a81629962ade8afd967826ed.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_n" src="/wiki/images/math/6/7/b/67b68721103b5a16194f4b3e3ec222db.png" />, we observe that we can categorize all possible paths according to the last step taken. That is, we either get from <img class="mwe-math-fallback-image-inline tex" alt="x_0" src="/wiki/images/math/0/b/2/0b21a666a81629962ade8afd967826ed.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_{n-1}" src="/wiki/images/math/3/2/0/320eb171f9774f65eafb058ec460bf39.png" /> and then take one additional step from <img class="mwe-math-fallback-image-inline tex" alt="x_{n-1}" src="/wiki/images/math/3/2/0/320eb171f9774f65eafb058ec460bf39.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_n" src="/wiki/images/math/6/7/b/67b68721103b5a16194f4b3e3ec222db.png" />, or we get from <img class="mwe-math-fallback-image-inline tex" alt="x_0" src="/wiki/images/math/0/b/2/0b21a666a81629962ade8afd967826ed.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_{n-2}" src="/wiki/images/math/f/2/0/f2039eed8294f00e8508917388eb9110.png" /> and then take one additional step from <img class="mwe-math-fallback-image-inline tex" alt="x_{n-2}" src="/wiki/images/math/f/2/0/f2039eed8294f00e8508917388eb9110.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_n" src="/wiki/images/math/6/7/b/67b68721103b5a16194f4b3e3ec222db.png" />, or we get from <img class="mwe-math-fallback-image-inline tex" alt="x_0" src="/wiki/images/math/0/b/2/0b21a666a81629962ade8afd967826ed.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_{n-3}" src="/wiki/images/math/6/8/1/681cfb75186ac07345b5d822b0cc664b.png" /> and then take one additional step from <img class="mwe-math-fallback-image-inline tex" alt="x_{n-3}" src="/wiki/images/math/6/8/1/681cfb75186ac07345b5d822b0cc664b.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_n" src="/wiki/images/math/6/7/b/67b68721103b5a16194f4b3e3ec222db.png" />, and so on. The categories are <i>disjoint</i> in the sense that two paths from different categories are never the same path, since two paths cannot possibly be the same if their last steps are not the same. They are <i>exhaustive</i> in the sense that every possible path from <img class="mwe-math-fallback-image-inline tex" alt="x_0" src="/wiki/images/math/0/b/2/0b21a666a81629962ade8afd967826ed.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_n" src="/wiki/images/math/6/7/b/67b68721103b5a16194f4b3e3ec222db.png" /> will end up in one of the categories (in particular, if its last step is from <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="/wiki/images/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_n" src="/wiki/images/math/6/7/b/67b68721103b5a16194f4b3e3ec222db.png" />, then it ends up in the same category as all the other paths whose last step is from <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="/wiki/images/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_n" src="/wiki/images/math/6/7/b/67b68721103b5a16194f4b3e3ec222db.png" />).
</p><p>Having made this observation&#8212;and categorized all the paths&#8212;we can now count the total number of paths. Since the categories are disjoint and exhaustive, we simply add the number of paths in each category to obtain the total number of paths. But each category can be represented as a subproblem. The number of ways to go from <img class="mwe-math-fallback-image-inline tex" alt="x_0" src="/wiki/images/math/0/b/2/0b21a666a81629962ade8afd967826ed.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_n" src="/wiki/images/math/6/7/b/67b68721103b5a16194f4b3e3ec222db.png" /> with the last step being from <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="/wiki/images/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_n" src="/wiki/images/math/6/7/b/67b68721103b5a16194f4b3e3ec222db.png" /> is the same as the number of ways to go from <img class="mwe-math-fallback-image-inline tex" alt="x_0" src="/wiki/images/math/0/b/2/0b21a666a81629962ade8afd967826ed.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="/wiki/images/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png" />, period.
</p><p>So we can finally conclude that the total number of ways to go from <img class="mwe-math-fallback-image-inline tex" alt="x_0" src="/wiki/images/math/0/b/2/0b21a666a81629962ade8afd967826ed.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_n" src="/wiki/images/math/6/7/b/67b68721103b5a16194f4b3e3ec222db.png" /> is the <i>sum</i> of the number of ways to go from <img class="mwe-math-fallback-image-inline tex" alt="x_0" src="/wiki/images/math/0/b/2/0b21a666a81629962ade8afd967826ed.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="/wiki/images/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png" /> for all <img class="mwe-math-fallback-image-inline tex" alt="i" src="/wiki/images/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png" /> such that we can make the trip from <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="/wiki/images/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="x_n" src="/wiki/images/math/6/7/b/67b68721103b5a16194f4b3e3ec222db.png" /> in a single step (that is, <img class="mwe-math-fallback-image-inline tex" alt="A \leq x_n - x_i \leq B" src="/wiki/images/math/1/2/e/12e25d73b746314f357c99b50b334a68.png" />).
</p>
<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=9" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Consider the standard set of locations in the problem statement: 0, 990, 1010, 1970, 2030, 2940, 3060, 3930, 4060, 4970, 5030, 5990, 6010, 7000. Let <img class="mwe-math-fallback-image-inline tex" alt="A = 970" src="/wiki/images/math/7/f/f/7ff6c1e927bf730eb19442285f33003f.png" /> and <img class="mwe-math-fallback-image-inline tex" alt="B = 1040" src="/wiki/images/math/4/6/f/46fb502f027061f8d34b932e6a524ee5.png" />. The problem statement tells us that there are four ways to make the trip; we will see how to compute this number.
</p><p>As indicated above, in order to count trips from 0 to 7000, we should consider all possible final legs of the trip, that is, consider every possible motel that is between 970 and 1040 km away from our final destination and assume that we will first travel there in some number of days, stay the night there, and then drive to the final destination on the final day. There are two possible motels that could come just before our final destination: the one at 5990 and the one at 6010.
</p><p>By trial and error, we can determine by hand that there is one possible path that ends up at 5990, that is: 0-990-1970-2940-3930-4970-5990. There are also three possible paths that end up at 6010: 0-990-1970-2940-3930-4970-6010, 0-990-2030-3060-4060-5030-6010, 0-1010-2030-3060-4060-5030-6010. From the one path ending at 5990, we can construct one path ending at 7000 with final leg 5990, simply by appending it onto the end: 0-990-1970-2940-3930-4970-5990-7000. From the three paths ending at 6010, we can construct three paths ending at 7000 with final leg 6010, simply by appending the leg 6010-7000 to the end of each one: 0-990-1970-2940-3930-4970-6010-7000, 0-990-2030-3060-4060-5030-6010-7000, 0-1010-2030-3060-4060-5030-6010-7000. We see that all four of the paths we obtained in this way are distinct, and, furthermore, they cover all possible paths from 0 to 7000, because if we take any path from 0 to 7000, either it ends in 5990-7010 or it ends in 6010-7010, and then after removing the final leg we must get a valid path to 5990 or a valid path to 6010, and we have enumerated all of those already. We conclude that, to find the number of paths from 0 to 7000, we add the number of paths from 0 to 5990 and the number of paths from 0 to 6010. If <img class="mwe-math-fallback-image-inline tex" alt="A" src="/wiki/images/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png" /> and <img class="mwe-math-fallback-image-inline tex" alt="B" src="/wiki/images/math/9/d/5/9d5ed678fe57bcca610140957afab571.png" /> were different, we might have to consider a different set of penultimate destinations, but the idea is the same.
</p>
<h3><span class="mw-headline" id="Pseudocode_implementation">Pseudocode implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=10" title="Edit section: Pseudocode implementation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<pre>input n, sorted sequence x[], A, B
dp[0] &#8592; 1                    // one way to get from x_0 to x_0, namely, by not taking any steps at all
for i &#8712; [1..n]
    dp[i] &#8592; 0
    j = i-1
    while x[i] - x[j] &lt; A    // x_j is too close
        j = j - 1
    while x[i] - x[j] &#8804; B
        dp[i] = dp[i] + dp[j]
        j = j - 1
print dp[n]
</pre>
<h2><span class="mw-headline" id="Paths_in_a_DAG">Paths in a DAG</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=11" title="Edit section: Paths in a DAG">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>All counting problems solvable by DP are ultimately isomorphic to the problem of counting paths in a directed acyclic graph, or DAG. This problem itself has a simple DP solution, but more complicated problems can be solved by thinking of them in this way.
</p>
<h3><span class="mw-headline" id="Example_problem:_Water_Park">Example problem: Water Park</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=12" title="Edit section: Example problem: Water Park">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>We will start by considering the problem <a rel="nofollow" class="external text" href="http://wcipeg.com/problem/ccc07s4">Water Park</a>, which is similar to <i>Keep On Truckin'</i> but slightly more general. The input is a network of water slides. Each water slide connects two points, and you always slide from the higher point to the lowest point, for obvious reasons, but there may be multiple water slides that go into or come out of a single point. The problem is to determine how many different ways there are to go from the highest point (labelled 1) to the lowest point (labelled <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" />) by sliding down the given water slides. Two ways are different if at one of them uses a slide that the other one does not use.
</p><p>We solve this problem using reasoning very similar to that used in <i>Keep on Truckin'</i>. In order to count the number of paths from point 1 to some point <img class="mwe-math-fallback-image-inline tex" alt="p &gt; 1" src="/wiki/images/math/6/5/a/65adc4b897aa60664021c6bada94a071.png" />, we divide the paths into categories based on the last slide taken along the path. That is, for any given path from point 1 to point <img class="mwe-math-fallback-image-inline tex" alt="p" src="/wiki/images/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png" />, we either travelled directly from point 1 to point <img class="mwe-math-fallback-image-inline tex" alt="p" src="/wiki/images/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png" />, or we travelled from point 1 to point 2 then took a final, additional slide from point 2 to point <img class="mwe-math-fallback-image-inline tex" alt="p" src="/wiki/images/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png" />, or we travelled from point 1 to point 3 then took a final, additional slide from point 3 to point <img class="mwe-math-fallback-image-inline tex" alt="p" src="/wiki/images/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png" />, and so on. These categories of paths are disjoint because two paths from different categories have different final slides and therefore cannot be the same; they are exhaustive because every path from point 1 to point <img class="mwe-math-fallback-image-inline tex" alt="p" src="/wiki/images/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png" /> has to have <i>some</i> final slide and will hence end up in that slide's category. Finally, the size of each category is the number of paths from point 1 to the initial point of the final slide corresponding to that category.
</p><p>We conclude that, in order to compute the number of paths from point 1 to point <img class="mwe-math-fallback-image-inline tex" alt="p" src="/wiki/images/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png" />, we make a list of slides that lead directly into point <img class="mwe-math-fallback-image-inline tex" alt="p" src="/wiki/images/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png" />, and then add up the number of paths into the initial point of each slide. Denote the initial point of a slide by <img class="mwe-math-fallback-image-inline tex" alt="i(S)" src="/wiki/images/math/6/3/6/6361cc6dbddf6778fd787468921d8c4e.png" /> and the terminal point by <img class="mwe-math-fallback-image-inline tex" alt="t(S)" src="/wiki/images/math/a/2/8/a28959aee0db9615b92874f7a3785e81.png" />. Thus:
</p>
<dl><dd><img class="mwe-math-fallback-image-inline tex" alt="\displaystyle f(p) = \begin{cases} 1 &amp; p = 1 \\ \sum_{i(S) = p} \, f(t(S)) &amp; p &gt; 1 \end{cases}" src="/wiki/images/math/3/8/2/382e13793a5d8a7d9d26b35ba9880f8d.png" /></dd></dl>
<p>We could also express this as follows:
</p>
<dl><dd><img class="mwe-math-fallback-image-inline tex" alt="\displaystyle f(p) = \begin{cases} 1 &amp; p = 1 \\ \sum_{q &lt; p} \, n_{qp} f(q) &amp; p &gt; 1 \end{cases}" src="/wiki/images/math/8/7/9/8797d360177fe98e7ebf470b890c5cde.png" /></dd></dl>
<p>where we sum over all vertices higher (lower-numbered) than <img class="mwe-math-fallback-image-inline tex" alt="p" src="/wiki/images/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png" /> and <img class="mwe-math-fallback-image-inline tex" alt="n_{pq}" src="/wiki/images/math/f/5/0/f50ae40ec066159638499d60312dd664.png" /> is the number of slides from <img class="mwe-math-fallback-image-inline tex" alt="q" src="/wiki/images/math/7/6/9/7694f4a66316e53c8cdd9d9954bd611d.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="p" src="/wiki/images/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png" />. (Note that the problem statement does not rule out multiple slides between the same pair of points!)
</p>
<h3><span class="mw-headline" id="Example_2">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=13" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Again, an example will help to illuminate the discussion. Suppose there are slides from 1 to 2, 1 to 3, 1 to 4, 2 to 3, 2 to 4, and 3 to 4. We want to compute the number of paths from point 1 to point 4. To do this, we first make a list of all the slides leading directly into point 4. There are three of these: 1-4, 2-4, and 3-4. Then we add the number of paths from 1 to 4 that end with the 1-4 slide, the number of paths from 1 to 4 that end with the 2-4 slide, and the number of paths from 1 to 4 that end with the 3-4 slide.
</p><p>There is one path from 1 to 2: 1-2 (a single slide). We can obtain a path from 1 to 4 by adjoining 1-4, hence: 1-2-4. There are two paths from 1 to 3: 1-2-3 and 1-3; from these we obtain two paths from 1 to 4: 1-2-3-4 and 1-3-4. Finally, we shouldn't forget the direct path 1-4. We see that <img class="mwe-math-fallback-image-inline tex" alt="f(4) = f(1) + f(2) + f(3)" src="/wiki/images/math/0/e/8/0e82f47f3689d82ea6cea8271fd9bbf0.png" />; <img class="mwe-math-fallback-image-inline tex" alt="f(1)" src="/wiki/images/math/4/4/f/44f2886de47a6ed1bd8d3b95c3125295.png" /> counts the one path from 1 directly to 4, <img class="mwe-math-fallback-image-inline tex" alt="f(2)" src="/wiki/images/math/8/0/4/804c00b3d22f9440a6e493617abf01fe.png" /> counts the one path from 1 to 2 then directly to 4, and <img class="mwe-math-fallback-image-inline tex" alt="f(3)" src="/wiki/images/math/d/1/0/d10299b8ce8e24128b8cdd510c51da75.png" /> counts the two paths from 1 to 3 and then directly to 4. This covers all possible paths from 1 to 4 with no double-counting.
</p>
<h3><span class="mw-headline" id="Generalization">Generalization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=14" title="Edit section: Generalization">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This problem may be abstracted as follows: you are given a <a href="/wiki/Directed_acyclic_graph" title="Directed acyclic graph">directed acyclic graph</a>. The network of water slides is a graph, where each point is a vertex and each slide is an edge; it is directed because you can only go one way along each edge; and it is acyclic because you cannot proceed down a sequence of slides and get back to where you started from (you will always end up somewhere lower). You want to determine how many different paths there are in this graph between a given pair of nodes, say, node <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> and node <img class="mwe-math-fallback-image-inline tex" alt="t" src="/wiki/images/math/e/3/5/e358efa489f58062f10dd7316b65649e.png" />.
</p><p>The general solution is to visit nodes in <a href="/wiki/index.php?title=Topological_order&amp;action=edit&amp;redlink=1" class="new" title="Topological order (page does not exist)">topological order</a> from <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="t" src="/wiki/images/math/e/3/5/e358efa489f58062f10dd7316b65649e.png" />; that is, visit nodes in an order such that, by time time we visit a node, we have already visited all the nodes with edges leading into that node. In <i>Water Park</i>, this was easy: we just visit nodes in increasing numerical order. In general, this problem has disjoint and exhaustive substructure and we use the formula
</p>
<dl><dd><img class="mwe-math-fallback-image-inline tex" alt="\displaystyle f(s, u) = \begin{cases} 1 &amp; u = s \\ \sum_{e = (v, u) \in E} \, f(s, v) &amp; \text{otherwise} \end{cases}" src="/wiki/images/math/5/3/3/53356e02ef5c361a29e0e2603c7fa0bd.png" /></dd></dl>
<p>where the bottom line tells to sum over all edges <img class="mwe-math-fallback-image-inline tex" alt="e \in E" src="/wiki/images/math/5/3/3/53375db67b95672b2b0522f38d12b96e.png" /> into <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />; in the summand, <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> denotes the vertex that edge points away from.
</p><p>Many optimization problems can be cast into a similar paradigm; here the analogous problem is finding the shortest (or longest) path between two vertices in a DAG, where each edge has some real number, its length. (Usually the problem would in fact be to find the optimal length, rather than the path itself.) We can now revisit <i>Plentiful Paths</i> in this light. The entire field may be considered a DAG, where each square is a vertex and there is an edge from one square to another if they are adjacent and the latter is either above or to the right of the former. Label an edge with 1 if its destination vertex contains an apple, or 0 if it does not. In this way, every possible way we can travel from the lower-left corner to the upper-right corner is assigned a weight that equals the number of apples we can collect along this path. (Actually, it will be off by one if the initial square contains an apple, but this effects only a trivial modification to the algorithm.) The problem is therefore to find the longest path between the vertices corresponding to the lower-left and upper-right squares in the DAG, and we use the formula
</p>
<dl><dd><img class="mwe-math-fallback-image-inline tex" alt="\displaystyle f(s, u) = \begin{cases} 0 &amp; u = s \\ \max_{e = (v, u) \in E} \, f(s, v) + w(e) &amp; \text{otherwise} \end{cases}" src="/wiki/images/math/d/b/0/db0a96e9041955d20b35050fc25326f9.png" /></dd></dl>
<p>where <img class="mwe-math-fallback-image-inline tex" alt="w(e)" src="/wiki/images/math/c/6/6/c66234702b1823f30e52c17af6607a21.png" /> is the length or weight of the edge <img class="mwe-math-fallback-image-inline tex" alt="e" src="/wiki/images/math/e/1/6/e1671797c52e15f763380b45e841ec32.png" />. To find a shortest path instead of a longest path, replace <img class="mwe-math-fallback-image-inline tex" alt="\max" src="/wiki/images/math/9/a/c/9ac24059464ca54850fc0f0f2b96d8fb.png" /> with <img class="mwe-math-fallback-image-inline tex" alt="\min" src="/wiki/images/math/c/d/f/cdfd765ebd17f8613962235becb89913.png" />, or multiply all edge weights by -1. The meaning of this formula in this specific case is as follows: <img class="mwe-math-fallback-image-inline tex" alt="f(s, v)" src="/wiki/images/math/3/d/8/3d86944bf9f8dea4f0997d9ad938324f.png" /> is the maximum number of apples that could've been collected by travelling from <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" />, and <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> is either directly below or directly to the left of <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />, since it must be possible to travel directly from <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />. <img class="mwe-math-fallback-image-inline tex" alt="w(e)" src="/wiki/images/math/c/6/6/c66234702b1823f30e52c17af6607a21.png" /> is 1 if there is an apple in square <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />, and 0 otherwise. By taking the maximum value of <img class="mwe-math-fallback-image-inline tex" alt="f(s, v) + w(e)" src="/wiki/images/math/0/e/a/0ea76ea400e15106cd5a7196f10ed963.png" /> for the two possible choices of <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" />, we're selecting the predecessor square with the better optimum path (since <img class="mwe-math-fallback-image-inline tex" alt="w(e)" src="/wiki/images/math/c/6/6/c66234702b1823f30e52c17af6607a21.png" /> in this case is independent of <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" />). All this is exactly the same as in the original solution.
</p>
<h3><span class="mw-headline" id="State_and_dimension">State and dimension</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit&amp;section=15" title="Edit section: State and dimension">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Problems that involve travelling from one place or another often obviously fall into the DAG paradigm, but the paradigm is far more general than that. Indeed, traversing a DAG topologically is the essence of DP. In all the examples we've seen so far, we would likely use an array to store the values we have computed so far. Some entries in this array depend on others, and there is usually an obvious base case (an entry we can write down trivially without examining any others) and our objective is to compute some particular entry. Of course, two entries should not depend on each other, because then we would have no way to compute either of them. This system of dependencies can be expressed by identifying each entry of the array with a vertex of the DAG and each dependency as an edge; the base case corresponds to a source of the DAG, and the final entry we want is usually a sink (since there is no point in computing additional entries that depend on the answer after we have already computed the answer).
</p><p>The key to solving any problem by DP, then, is to find a useful way to construct a DAG such that each vertex's value is some function of only the values of the vertices with edges leading into it (and not the details of the path taken from the source to those vertices), and where it is simple to compute the value of the source, and, finally, where the value of the sink will be the answer to the problem instance. If the DAG is not big enough, then the rule that each vertex's value must depend only on the values of the vertices immediately before it won't be satisfied; if it's too big, then the algorithm will likely be inefficient since we need to compute the values of all (or almost all) other vertices before we can get to the value we want at the sink.
</p><p>We say that we want to pick the appropriate <b>states</b> and <b>transitions</b>. A state is a vertex of the DAG, and we will usually represent it with one or more integers, indices into the array we use to do the DP. Transitions are identified with the edges leading into any given vertex, and represented by a transition function <img class="mwe-math-fallback-image-inline tex" alt="g" src="/wiki/images/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png" />, so that <img class="mwe-math-fallback-image-inline tex" alt="f(u) = g(f(v_1), f(v_2), ...)" src="/wiki/images/math/4/1/0/410f7aea296680dfdd220125f053d533.png" /> where <img class="mwe-math-fallback-image-inline tex" alt="f" src="/wiki/images/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png" /> is the function we are trying to compute and <img class="mwe-math-fallback-image-inline tex" alt="v_1, v_2, ..." src="/wiki/images/math/a/c/e/ace924ba022b00b5c7f81f8342b99068.png" /> are the vertices with an edge pointing out of them into the vertex <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> of interest. (The case of multiple edges between a given pair of vertices is similar.) Usually, the number of states in the DP will be approximately <img class="mwe-math-fallback-image-inline tex" alt="N^k" src="/wiki/images/math/9/b/2/9b26da59c6f2e8d286e44da6bc603750.png" /> for some positive integer <img class="mwe-math-fallback-image-inline tex" alt="k" src="/wiki/images/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png" />, where <img class="mwe-math-fallback-image-inline tex" alt="N" src="/wiki/images/math/8/d/9/8d9c307cb7f3c4a32822a51922d1ceaa.png" /> is the size of the problem instance. If this is the case, we call the DP <b><img class="mwe-math-fallback-image-inline tex" alt="k" src="/wiki/images/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png" />-dimensional</b>; we will probably use a <img class="mwe-math-fallback-image-inline tex" alt="k" src="/wiki/images/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png" />-dimensional array to store the values computed so far.
</p>
<!-- 
NewPP limit report
CPU time usage: 0.171 seconds
Real time usage: 0.191 seconds
Preprocessor visited node count: 1347/1000000
Preprocessor generated node count: 3088/1000000
Post‐expand include size: 400/2097152 bytes
Template argument size: 72/2097152 bytes
Highest expansion depth: 4/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%   74.492      1 - -total
 12.92%    9.622      4 - Template:Problem
  7.40%    5.515      4 - Template:JudgeRoot
  3.70%    2.757      4 - Template:Root
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:12-0!*!0!!en!*!*!math=0 and timestamp 20180417161107 and revision id 1949
 -->
</div>									<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://wcipeg.com/wiki/index.php?title=Dynamic_programming&amp;oldid=1949">https://wcipeg.com/wiki/index.php?title=Dynamic_programming&amp;oldid=1949</a>"					</div>
													<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="/wiki/Category:Algorithms" title="Category:Algorithms">Algorithms</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-createaccount"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Dynamic+programming&amp;type=signup" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li><li id="pt-login"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Dynamic+programming" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
															<li  id="ca-nstab-main" class="selected"><span><a href="/wiki/Dynamic_programming"  title="View the content page [c]" accesskey="c">Page</a></span></li>
															<li  id="ca-talk"><span><a href="/wiki/Talk:Dynamic_programming"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a href="/wiki/Dynamic_programming" >Read</a></span></li>
															<li id="ca-edit"><span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=edit"  title="You can edit this page. Please use the preview button before saving [e]" accesskey="e">Edit</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="/wiki/index.php?title=Dynamic_programming&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>

						<form action="/wiki/index.php" id="searchform">
														<div id="simpleSearch">
															<input type="search" name="search" placeholder="Search" title="Search PEGWiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />								</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="/wiki/Main_Page"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
			<h3 id='p-navigation-label'>Navigation</h3>

			<div class="body">
									<ul>
													<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
													<li id="n-Index"><a href="/wiki/Special:AllPages">Index</a></li>
													<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
													<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
													<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
			<h3 id='p-tb-label'>Tools</h3>

			<div class="body">
									<ul>
													<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Dynamic_programming" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
													<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Dynamic_programming" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
													<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
													<li id="t-print"><a href="/wiki/index.php?title=Dynamic_programming&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
													<li id="t-permalink"><a href="/wiki/index.php?title=Dynamic_programming&amp;oldid=1949" title="Permanent link to this revision of the page">Permanent link</a></li>
													<li id="t-info"><a href="/wiki/index.php?title=Dynamic_programming&amp;action=info" title="More information about this page">Page information</a></li>
											</ul>
							</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 9 February 2016, at 14:38.</li>
											<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by/3.0/">Attribution 3.0 Unported</a> unless otherwise noted.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="/wiki/PEGWiki:Privacy_policy" title="PEGWiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/wiki/PEGWiki:About" title="PEGWiki:About">About PEGWiki</a></li>
											<li id="footer-places-disclaimer"><a href="/wiki/PEGWiki:General_disclaimer" title="PEGWiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
															<a href="http://creativecommons.org/licenses/by/3.0/"><img src="http://i.creativecommons.org/l/by/3.0/88x31.png" alt="Attribution 3.0 Unported" width="88" height="31" /></a>
													</li>
											<li id="footer-poweredbyico">
															<a href="//www.mediawiki.org/"><img src="/wiki/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/wiki/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /wiki/resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" /></a>
													</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>if(window.jQuery)jQuery.ready();</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.toc","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"https://wcipeg.com/wiki/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=vector\u0026amp;*\"\u003E\u003C/script\u003E");
}</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":79});
}</script>
	</body>
</html>
