<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" />
<title>String searching - PEGWiki</title>
<meta name="generator" content="MediaWiki 1.25.2" />
<link rel="alternate" type="application/x-wiki" title="Edit" href="/wiki/index.php?title=String_searching&amp;action=edit" />
<link rel="edit" title="Edit" href="/wiki/index.php?title=String_searching&amp;action=edit" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/wiki/opensearch_desc.php" title="PEGWiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://wcipeg.com/wiki/api.php?action=rsd" />
<link rel="alternate" hreflang="x-default" href="/wiki/String_searching" />
<link rel="copyright" href="http://creativecommons.org/licenses/by/3.0/" />
<link rel="alternate" type="application/atom+xml" title="PEGWiki Atom feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=ext.math.styles%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wikidb:resourceloader:filter:minify-css:7:b36fd1c042133c9c9b60260f7c29b237 */</style>
<script src="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"String_searching","wgTitle":"String searching","wgCurRevisionId":1313,"wgRevisionId":1313,"wgArticleId":232,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"String_searching","wgRelevantArticleId":232,"wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});});
/* cache key: wikidb:resourceloader:filter:minify-js:7:a5c52c063dc436c1ca7c9f456936a5e9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/wiki/skins/Vector/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-String_searching skin-vector action-view">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

						<div class="mw-indicators">
</div>
			<h1 id="firstHeading" class="firstHeading" lang="en">String searching</h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">From PEGWiki</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>The <b>string searching</b> or <b>string matching</b> problem is that of locating one <a href="/wiki/String" title="String">string</a>, known as a <b>needle</b> or a <b>pattern</b>, as a substring of another, longer string, known as a <b>haystack</b> or the <b>text</b>. (These terms are derived from the idiom <i>finding a needle in a haystack</i>.) It is precisely the function implemented by the "Find" feature in a text editor or web browser. Because of the information explosion and the fact that much of the information in the world exists in the form of text, efficient information retrieval by means of string searching is instrumental in a wide variety of applications. Consequently, this problem is one of the most extensively studied in computer science. The more general problem of determining whether a text contains a substring of a particular form, such as a <a href="/wiki/index.php?title=Regular_expression&amp;action=edit&amp;redlink=1" class="new" title="Regular expression (page does not exist)">regular expression</a>, is known as <b><a href="/wiki/index.php?title=Pattern_matching&amp;action=edit&amp;redlink=1" class="new" title="Pattern matching (page does not exist)">pattern matching</a></b>.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Discussion"><span class="tocnumber">1</span> <span class="toctext">Discussion</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Naive_algorithm"><span class="tocnumber">2</span> <span class="toctext">Naive algorithm</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Knuth.E2.80.93Morris.E2.80.93Pratt_algorithm"><span class="tocnumber">3</span> <span class="toctext">Knuth–Morris–Pratt algorithm</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Rabin.E2.80.93Karp_algorithm"><span class="tocnumber">4</span> <span class="toctext">Rabin–Karp algorithm</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Aho.E2.80.93Corasick_algorithm"><span class="tocnumber">5</span> <span class="toctext">Aho–Corasick algorithm</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Suffix_data_structures"><span class="tocnumber">6</span> <span class="toctext">Suffix data structures</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Boyer.E2.80.93Moore_algorithm"><span class="tocnumber">7</span> <span class="toctext">Boyer–Moore algorithm</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Discussion">Discussion</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=String_searching&amp;action=edit&amp;section=1" title="Edit section: Discussion">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In theory, the string searching problem could be formulated as a decision problem, the problem of whether or not the needle <i>is</i> a substring of the haystack. However, this variation is often not used in practice, since we almost always want to know <i>where</i> the needle occurs in the haystack, and none of the important string searching algorithms make it difficult to determine this once they have established that the substring exists. (For example, the string <b>mat</b> appears twice in <b>mathematics</b>, once starting from the first character, and once starting from the sixth character.) On the other hand, sometimes we will only care about the first or the last position at which the needle occurs in the haystack, and other times we will want to find <i>all</i> positions at which it matches.
</p><p>If a string searching algorithm is to be used on only one needle-haystack pair, its efficiency is determined by two factors: the length of the needle, <img class="mwe-math-fallback-image-inline tex" alt="m" src="/wiki/images/math/6/f/8/6f8f57715090da2632453988d9a1501b.png" />, and the length of the haystack, <img class="mwe-math-fallback-image-inline tex" alt="n" src="/wiki/images/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png" />. Several algorithms achieve the asymptotically optimal <img class="mwe-math-fallback-image-inline tex" alt="\Theta(m+n+p)" src="/wiki/images/math/6/2/d/62dbd596ae64943badc380e70ee1506b.png" /> worst-case runtime here (where <img class="mwe-math-fallback-image-inline tex" alt="p" src="/wiki/images/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png" /> is the number of matches found for the needle in the haystack), which is linear time.
</p><p>We will sometimes want to search for one pattern in multiple texts; the "Search" feature of your operating system, for example, will accept one search string and attempt to locate it in multiple files. Using any single-pattern, single-text linear-time string searching algorithm for this case will also give an asymptotically optimal linear-time algorithm, as it will use <img class="mwe-math-fallback-image-inline tex" alt="O(m + n_1 + m + n_2 + ...)" src="/wiki/images/math/e/f/9/ef923c49e5052cc0dc3e66139bec4d84.png" /> time, which is the same as <img class="mwe-math-fallback-image-inline tex" alt="O(n_1 + n_2 + ...)" src="/wiki/images/math/5/3/5/5351a0944150174d731ba945713ade4a.png" /> since the needle is never longer than the haystack (and hence the sum of the needle and haystack lengths is never more than twice the haystack length). That is, preprocessing the needle will not give a multiple-text string searching algorithm that is asymptotically faster than running an asymptotically optimal single-pattern, single-text algorithm once on each text.
</p><p>The situation is very different when we want to search for multiple patterns in one text. As an example, a biologist may frequently wish to locate genes in the human genome. This 3.3 billion-character text produced through the efforts of the Human Genome Project does not change, but the there are undoubtedly a great number of different genes (patterns) that biologists may wish to locate in it. Here, if we run a single-pattern, single-text algorithm for each pattern, we have to consider the entire text each time. When the text is much longer than the patterns, the behavior of this strategy is much worse than linear time. It is possible to <i>preprocess</i> the text so that it will not be necessary to iterate through the entire text each time a new pattern is searched for within it. This is known as <b>indexing</b>.
</p>
<h2><span class="mw-headline" id="Naive_algorithm">Naive algorithm</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=String_searching&amp;action=edit&amp;section=2" title="Edit section: Naive algorithm">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A straightforward string search algorithm looks as follows. Let the characters of the needle be denoted <img class="mwe-math-fallback-image-inline tex" alt="x[1], x[2], ..., x[m]" src="/wiki/images/math/e/a/7/ea79eee8fc5d78241b06b8098b61773c.png" /> and those of the haystack <img class="mwe-math-fallback-image-inline tex" alt="y[1], y[2], ..., y[n]" src="/wiki/images/math/d/8/7/d87b36f6ee50df2ce81f817c3dbd32c4.png" />:
</p>
<pre>for i &#8712; [0..n-m]
     match &#8592; true
     for j &#8712; [1..m]
          if x[j] = y[i+j]
               match &#8592; false
               break
     if match
          {needle found starting at position i+1 of haystack}
</pre>
<p>That is, every possible position in the haystack is considered a potential match and tested one character at a time to determine whether it is an actual match. 
</p><p>Although this is a naive algorithm, in practice it is likely to run quite quickly when the needle and haystack are essentially random. This is because the <img class="mwe-math-fallback-image-inline tex" alt="j" src="/wiki/images/math/3/6/3/363b122c528f54df4a0446b6bab05515.png" /><sup>th</sup> character of the potential match will be examined if and only if the previous <img class="mwe-math-fallback-image-inline tex" alt="j-1" src="/wiki/images/math/5/a/a/5aa66ae2348be0b0928bfb00aeb33893.png" /> characters matched, which is expected to occur with probability <img class="mwe-math-fallback-image-inline tex" alt="|\Sigma|^{-(j-1)}" src="/wiki/images/math/1/e/9/1e93bbdb03169766008de4f5708c5204.png" />. Thus, in the infinite limit, the expected number of characters examined for each partial match is <img class="mwe-math-fallback-image-inline tex" alt="1 + |\Sigma|^{-1} + |\Sigma|^{-2} + ... = |\Sigma|/(|\Sigma|-1) \approx 1" src="/wiki/images/math/a/8/7/a873d80846873ca3c27c4350f575387c.png" /> when <img class="mwe-math-fallback-image-inline tex" alt="|\Sigma|" src="/wiki/images/math/0/4/7/0478c6fa35679d614a258cbe756aa348.png" />, the alphabet size, is large. This is equivalent to saying that mismatches will usually be found quite early, giving a linear runtime.
</p><p>Unfortunately, this analysis is far too optimistic, because searching for a completely random needle in a completely random haystack is not very useful.
In practice, when searching, we will often already know that the needle is somewhere within the haystack. If using the "Search and Replace" feature of a text editor, we often know the needle occurs <i>several times</i> within the haystack. Under these circumstances, the naive algorithm is likely to perform much worse. A worst case occurs when, for example, the needle is <b>AAAAAAA</b> and the haystack is <b>AAAAAAAAAAAA</b>. Here, seven positions of the haystack have to be checked, and in each case all seven characters of the substring beginning there have to be checked to verify the potential match. In general, the naive algorithm has running time <img class="mwe-math-fallback-image-inline tex" alt="O(mn)" src="/wiki/images/math/0/c/a/0ca5e4e27ca8dc4c891d2c8598529ed1.png" />, which is far too slow for many real-world applications involving vast quantities of text.
</p>
<h2><span class="mw-headline" id="Knuth.E2.80.93Morris.E2.80.93Pratt_algorithm">Knuth–Morris–Pratt algorithm</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=String_searching&amp;action=edit&amp;section=3" title="Edit section: Knuth–Morris–Pratt algorithm">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To see how the naive algorithm can be improved, consider two examples. The first is the worst-case example of searching for a string of seven <b>A'</b>s in a string of thirteen <b>A'</b>s. The naive algorithm will first check the substring of the haystack located from positions 1 to 7, inclusive, and find a match. Then it will check the substring in positions 2 to 8, inclusive, and so on. But no human would search this way, because in this case, the first match tells us that <i>the characters from positions 2 to 7 are all <b>A'</b>s</i>, which means that instead of re-checking all the characters from positions 2 to 8 <i>we only need to check the eighth character</i>. As long as we keep finding <b>A'</b>s, each of them signals a new match, and we never have to look back.
</p><p>Furthermore, when we encounter a different character in the haystack, such as <b>B</b>, as in the string <b>AAAAAABAAAAAAA</b>, this gives us useful information as well. In particular, since the character <b>B</b> occurs at position 7 in the haystack, and the needle contains no <b>B</b>s at all, after a failed match at positions 1 to 7, we can immediately rule out the possibilities of finding matches at positions 2 to 8, 3 to 9, 4 to 10, 5 to 11, 6 to 12, and 7 to 13, and continue our search starting from character 8.
</p><p>Another example: suppose we are searching for the string <b>tartan</b> in the string <b>tartaric_acid</b>. We make the observation that, in the needle, the <b>ta</b> starting at the fourth position is identical to the <b>ta</b> starting at the first position. Now, when we perform the search, we start by testing the substring <b>tartar</b> (<i>i.e.</i>, at position 1 of the haystack); we see the the first five characters match but that we then have a mismatch with tarta<b>n</b> and tarta<b>r</b>ic_acid. At this point, we first notice that we already have some partial match information. In particular, we can rule out the second and third positions of the haystack, and when we start trying to match the fourth position (the substring <b>taric_</b>), there is no need to start from the <b>t</b>, because we know that this <b>ta</b> already matches the <b>ta</b>rtar. We know this because when trying to match from the first position of <b>tartaric_acid</b> we found a match between <b>tarta</b>n and <b>tarta</b>ric_acid, <i>i.e.</i>, tar<b>ta</b>n matches tar<b>ta</b>ric_acid, and hence <b>ta</b>rtan matches tar<b>ta</b>ric acid (since we have already established that the substring <b>ta</b> occurs at both the first and the fourth positions of <b>tartan</b>). In this way we avoid examining the fourth and fifth characters of the haystack more than once.
</p><p>It may seem that a bit of human intelligence has been used in these examples, but it turns out that this "intelligence" is of a form that can be easily and exactly implemented on a computer. The needle is preprocessed in such a way that it becomes possible to eliminate potential positions after a failed match and to avoid re-checking characters on successful matches, and after a character from the haystack is examined, previous characters never need to be examined again. Furthermore, we do not have to store large substring match tables; instead, we can do it with linear time and linear space, giving an <img class="mwe-math-fallback-image-inline tex" alt="O(m+n)" src="/wiki/images/math/c/f/d/cfda60c744b8119ed03fe07e5c3722c9.png" /> algorithm overall. This is known as the <a href="/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" title="Knuth–Morris–Pratt algorithm">Knuth–Morris–Pratt algorithm</a> (<b>KMP</b>). This algorithm, however, is not suitable for searching for several needles in one haystack.
</p>
<h2><span class="mw-headline" id="Rabin.E2.80.93Karp_algorithm">Rabin–Karp algorithm</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=String_searching&amp;action=edit&amp;section=4" title="Edit section: Rabin–Karp algorithm">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Another approach is based on hashing. In particular, we first hash the needle and then hash each substring of the haystack of length <img class="mwe-math-fallback-image-inline tex" alt="m" src="/wiki/images/math/6/f/8/6f8f57715090da2632453988d9a1501b.png" /> (using the same hash function). By comparing the hash of each of these substrings of the haystack with the hash of the needle, we can rule out many positions in the haystack (<i>i.e.</i>, when the hashes do not match).
</p><p>The problem with this approach as presented is that a good hashing algorithm always examines all of the data, <i>i.e.</i>, the entire substring of the potential match. If this is the case, then <img class="mwe-math-fallback-image-inline tex" alt="O(m)" src="/wiki/images/math/0/e/2/0e2ae329177722b1818828e92b441032.png" /> time will be spent hashing each potential match, giving a runtime no better than that of the naive algorithm.
</p><p>Instead, we use a <i>rolling hash</i>. This is a hash function with the useful property that if we already know the hash of the substring in positions <img class="mwe-math-fallback-image-inline tex" alt="i+1, i+2, ..., i+m" src="/wiki/images/math/c/2/d/c2dae5bd57b6760392dfe8563d8b5763.png" /> of the haystack, then we can compute the hash of the substring <img class="mwe-math-fallback-image-inline tex" alt="i+2, i+3, ..., i+m+1" src="/wiki/images/math/7/f/e/7fec0c43b353435219b3fe8be0710e57.png" /> in constant time. (After all, only two characters actually change &#8212; one added and one removed &#8212; and the rest just slide over). The Rabin–Karp algorithm can be formulated either as a Monte Carlo algorithm (in which we assume that a match in hashes is an actual match, without bothering to verify the potential match, giving a linear runtime and a small probability of failure) or a Las Vegas algorithm (in which we verify each match in hashes as an actual match using the naive method, so that in the worst case in which every position is a match, we still get the naive <img class="mwe-math-fallback-image-inline tex" alt="O(mn)" src="/wiki/images/math/0/c/a/0ca5e4e27ca8dc4c891d2c8598529ed1.png" /> runtime, but we will always be correct) but not as a provably guaranteed correct and efficient algorithm. For this reason, the <a href="/wiki/Rabin%E2%80%93Karp_algorithm" title="Rabin–Karp algorithm">Rabin–Karp algorithm</a> is useful in programming contests, but rarely deployed in real-world applications. The Rabin–Karp algorithm does have the ability to efficiently search for multiple needles in one haystack by simply hashing each needle separately then checking whether the rolling hash of the haystack at each step matches <i>any</i> of the needle hashes. By storing the needle hashes in a <a href="/wiki/index.php?title=Hash_table&amp;action=edit&amp;redlink=1" class="new" title="Hash table (page does not exist)">hash table</a>, we obtain linear time.
</p>
<h2><span class="mw-headline" id="Aho.E2.80.93Corasick_algorithm">Aho–Corasick algorithm</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=String_searching&amp;action=edit&amp;section=5" title="Edit section: Aho–Corasick algorithm">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a href="/wiki/index.php?title=Aho%E2%80%93Corasick_algorithm&amp;action=edit&amp;redlink=1" class="new" title="Aho–Corasick algorithm (page does not exist)">Aho–Corasick algorithm</a> is more complex than KMP and Rabin–Karp, but it has the desirable property of exactly solving the multiple-pattern string search problem in linear time (unlike KMP, which is slow for multiple-pattern search, and Rabin–Karp, which has a small probability of either being slow or being incorrect). It builds a <a href="/wiki/index.php?title=Finite_automaton&amp;action=edit&amp;redlink=1" class="new" title="Finite automaton (page does not exist)">finite automaton</a> which at its core is a <a href="/wiki/index.php?title=Trie&amp;action=edit&amp;redlink=1" class="new" title="Trie (page does not exist)">trie</a> of entire set of patterns. The text is processed one character at a time, without looking back (as in KMP). Each node in the trie remembers which, if any, of the patterns are a suffix of the string represented by this node, so that once we have processed a character and passed through this node, we will know whether any substring <i>ending</i> at this character matches any of the patterns. If the current character in the text matches a branch from our current position in the trie, we proceed down that branch, as all the patterns in that branch are still potential matches. In case of a mismatch, we proceed to the longest possible suffix of the string to which the current position in the trie corresponds, which is made possible by augmenting the trie with <i>suffix links</i>.
</p><p>The Aho–Corasick algorithm is suitable when the set of patterns to be searched for is known in advance. For example, we might want a search engine to return all pages that contain <i>all</i> of the given search terms. This can be done by constructing the Aho–Corasick automaton of the search terms given and then executing a single search pass on each page. However, this might not always be the case; the example previously given was that of a webserver that locates genes within the human genome. Unless different biologists agree to batch together their queries, the Aho–Corasick algorithm will perform no better than KMP in this application.
</p>
<h2><span class="mw-headline" id="Suffix_data_structures">Suffix data structures</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=String_searching&amp;action=edit&amp;section=6" title="Edit section: Suffix data structures">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The final solution to multiple-pattern searching is given by data structures that index the suffixes of a string, namely, the <a href="/wiki/index.php?title=Suffix_tree&amp;action=edit&amp;redlink=1" class="new" title="Suffix tree (page does not exist)">suffix tree</a> and the <a href="/wiki/index.php?title=Suffix_array&amp;action=edit&amp;redlink=1" class="new" title="Suffix array (page does not exist)">suffix array</a>. The suffix tree is a compressed trie of all the suffixes of a given string. We can search for a substring simply by walking down starting from the root; if a corresponding branch ultimately does not exist then the needle is not found, and if it does, then all matches are to be found in the subtree rooted at the node we end up at. The suffix tree can be constructed in linear time, although the algorithm to do so is very complex; but constructing a suffix tree of the haystack allows a needle to be searched for in time proportional to its length (plus the number of matches, if we wish to return all of them). The suffix array is a sorted list of the suffixes of the string; if the needle is a prefix of any of the suffixes of the haystack then it is found at the positions at which those suffixes start, and clearly the matches will occur in a contiguous segment of the suffix array which can be determined using <a href="/wiki/Binary_search" title="Binary search">binary search</a>.
</p>
<h2><span class="mw-headline" id="Boyer.E2.80.93Moore_algorithm">Boyer–Moore algorithm</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=String_searching&amp;action=edit&amp;section=7" title="Edit section: Boyer–Moore algorithm">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a href="/wiki/index.php?title=Boyer%E2%80%93Moore_algorithm&amp;action=edit&amp;redlink=1" class="new" title="Boyer–Moore algorithm (page does not exist)">Boyer–Moore algorithm</a> is, on average, the fastest algorithm for single-pattern search. In the worst case it runs in linear time, but in the average case it examines only a fraction of the characters in the haystack. It does so by preprocessing the needle and then attempting to match the needle in <i>reverse order</i> while still considering possible match positions in the haystack in forward order. This allows it to rule out potential matches as soon as possible. For example, recall the example of looking for the needle <b>AAAAAAA</b> in the haystack <b>AAAAAABAAAAAAA</b>. Using KMP, we first match the first six characters of the needle to the first six characters of the haystack, at which point we discover that the seventh characters do not match. This allows us to rule out six other positions at which the needle might be found, so that we can resume processing the haystack at the first position <i>after</i> the <b>B</b>. The Boyer–Moore algorithm, on the other hand, would <i>start</i> by comparing AAAAAA<b>A</b> with AAAAAA<b>B</b>AAAAAAA, that is, by trying to match the <i>last</i> character of the needle. (If they match, then it would proceed to compare the second-last characters, and so on.) It would then find the mismatch immediately, and, using the information determined in the preprocessing stage, conclude the same information as KMP &#8212; that the search should resume starting at the eighth position of the haystack, at which point it would start matching from the end again, examining the fourteenth character first and then ultimately returning to the eighth character of the haystack and the first character of the needle, at which point a match is confirmed. Notice that Boyer–Moore did not even bother to examine the first six characters of the haystack. On average, then, the Boyer–Moore algorithm tends to run in time linear in the length of the needle plus sublinear in the length of the haystack.
</p>
<!-- 
NewPP limit report
CPU time usage: 0.041 seconds
Real time usage: 0.046 seconds
Preprocessor visited node count: 216/1000000
Preprocessor generated node count: 452/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:232-0!*!0!!en!*!*!math=0 and timestamp 20180417044035 and revision id 1313
 -->
</div>									<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://wcipeg.com/wiki/index.php?title=String_searching&amp;oldid=1313">https://wcipeg.com/wiki/index.php?title=String_searching&amp;oldid=1313</a>"					</div>
													<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-createaccount"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=String+searching&amp;type=signup" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li><li id="pt-login"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=String+searching" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
															<li  id="ca-nstab-main" class="selected"><span><a href="/wiki/String_searching"  title="View the content page [c]" accesskey="c">Page</a></span></li>
															<li  id="ca-talk" class="new"><span><a href="/wiki/index.php?title=Talk:String_searching&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a href="/wiki/String_searching" >Read</a></span></li>
															<li id="ca-edit"><span><a href="/wiki/index.php?title=String_searching&amp;action=edit"  title="You can edit this page. Please use the preview button before saving [e]" accesskey="e">Edit</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="/wiki/index.php?title=String_searching&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>

						<form action="/wiki/index.php" id="searchform">
														<div id="simpleSearch">
															<input type="search" name="search" placeholder="Search" title="Search PEGWiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />								</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="/wiki/Main_Page"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
			<h3 id='p-navigation-label'>Navigation</h3>

			<div class="body">
									<ul>
													<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
													<li id="n-Index"><a href="/wiki/Special:AllPages">Index</a></li>
													<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
													<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
													<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
			<h3 id='p-tb-label'>Tools</h3>

			<div class="body">
									<ul>
													<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/String_searching" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
													<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/String_searching" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
													<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
													<li id="t-print"><a href="/wiki/index.php?title=String_searching&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
													<li id="t-permalink"><a href="/wiki/index.php?title=String_searching&amp;oldid=1313" title="Permanent link to this revision of the page">Permanent link</a></li>
													<li id="t-info"><a href="/wiki/index.php?title=String_searching&amp;action=info" title="More information about this page">Page information</a></li>
											</ul>
							</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 6 April 2011, at 19:54.</li>
											<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by/3.0/">Attribution 3.0 Unported</a> unless otherwise noted.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="/wiki/PEGWiki:Privacy_policy" title="PEGWiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/wiki/PEGWiki:About" title="PEGWiki:About">About PEGWiki</a></li>
											<li id="footer-places-disclaimer"><a href="/wiki/PEGWiki:General_disclaimer" title="PEGWiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
															<a href="http://creativecommons.org/licenses/by/3.0/"><img src="http://i.creativecommons.org/l/by/3.0/88x31.png" alt="Attribution 3.0 Unported" width="88" height="31" /></a>
													</li>
											<li id="footer-poweredbyico">
															<a href="//www.mediawiki.org/"><img src="/wiki/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/wiki/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /wiki/resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" /></a>
													</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>if(window.jQuery)jQuery.ready();</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.toc","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"https://wcipeg.com/wiki/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=vector\u0026amp;*\"\u003E\u003C/script\u003E");
}</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":67});
}</script>
	</body>
</html>
