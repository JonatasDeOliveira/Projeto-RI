<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" />
<title>Cartesian tree - PEGWiki</title>
<meta name="generator" content="MediaWiki 1.25.2" />
<link rel="alternate" type="application/x-wiki" title="Edit" href="/wiki/index.php?title=Cartesian_tree&amp;action=edit" />
<link rel="edit" title="Edit" href="/wiki/index.php?title=Cartesian_tree&amp;action=edit" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/wiki/opensearch_desc.php" title="PEGWiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://wcipeg.com/wiki/api.php?action=rsd" />
<link rel="alternate" hreflang="x-default" href="/wiki/Cartesian_tree" />
<link rel="copyright" href="http://creativecommons.org/licenses/by/3.0/" />
<link rel="alternate" type="application/atom+xml" title="PEGWiki Atom feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=ext.math.styles%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wikidb:resourceloader:filter:minify-css:7:b36fd1c042133c9c9b60260f7c29b237 */</style>
<script src="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Cartesian_tree","wgTitle":"Cartesian tree","wgCurRevisionId":2000,"wgRevisionId":2000,"wgArticleId":413,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Trees","Data structures"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Cartesian_tree","wgRelevantArticleId":413,"wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});});
/* cache key: wikidb:resourceloader:filter:minify-js:7:a5c52c063dc436c1ca7c9f456936a5e9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/wiki/skins/Vector/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Cartesian_tree skin-vector action-view">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

						<div class="mw-indicators">
</div>
			<h1 id="firstHeading" class="firstHeading" lang="en">Cartesian tree</h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">From PEGWiki</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="thumb tright"><div class="thumbinner" style="width:252px;"><a href="/wiki/File:Cartesian_tree.svg" class="image"><img alt="" src="/wiki/images/thumb/d/d5/Cartesian_tree.svg/250px-Cartesian_tree.svg.png" width="250" height="240" class="thumbimage" srcset="/wiki/images/thumb/d/d5/Cartesian_tree.svg/375px-Cartesian_tree.svg.png 1.5x, /wiki/images/thumb/d/d5/Cartesian_tree.svg/500px-Cartesian_tree.svg.png 2x" /></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Cartesian_tree.svg" class="internal" title="Enlarge"></a></div>A sequence and its corresponding Cartesian tree</div></div></div>
<p>Given a sequence of numbers (or any <a href="/wiki/Totally_ordered" title="Totally ordered" class="mw-redirect">totally ordered</a> objects), there exists a <a href="/wiki/Binary_heap" title="Binary heap">binary min-heap</a> whose <a href="/wiki/index.php?title=Inorder_traversal&amp;action=edit&amp;redlink=1" class="new" title="Inorder traversal (page does not exist)">inorder traversal</a> is that sequence. This is known as the <b>Cartesian tree</b> for that sequence.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Construction"><span class="tocnumber">1</span> <span class="toctext">Construction</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Uniqueness"><span class="tocnumber">1.1</span> <span class="toctext">Uniqueness</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Naive_method"><span class="tocnumber">1.2</span> <span class="toctext">Naive method</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Left-to-right"><span class="tocnumber">1.3</span> <span class="toctext">Left-to-right</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Pseudocode"><span class="tocnumber">1.3.1</span> <span class="toctext">Pseudocode</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Proof_of_correctness"><span class="tocnumber">1.3.2</span> <span class="toctext">Proof of correctness</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Analysis_of_running_time"><span class="tocnumber">1.3.3</span> <span class="toctext">Analysis of running time</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-8"><a href="#Using_all_nearest_smaller_values"><span class="tocnumber">1.4</span> <span class="toctext">Using all nearest smaller values</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#Applications"><span class="tocnumber">2</span> <span class="toctext">Applications</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Construction">Construction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Cartesian_tree&amp;action=edit&amp;section=1" title="Edit section: Construction">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To see what such a tree would look like, imagine starting with the example sequence shown on the right. Because 1 is the smallest element in the sequence, it must occur at the root of the Cartesian tree (which is min-heap-ordered). Now, in an inorder traversal of the Cartesian tree, all the elements in the root's left subtree will be visited before the root, and all the elements in the right subtree after; so we can readily conclude that the elements 9, 3, and 7 occur in the left subtree, whereas 8, 12, 10, 20, 15, 18, and 5 occur in the right subtree.
</p><p>To actually construct the left subtree, we apply this reasoning recursively; the left subtree of the root is itself min-heap-ordered, so its root must be the element 3, as it is the smallest of 9, 3, and 7. Likewise, the root of the right subtree must be 5, which is the smallest of all the elements to the right of the 1; and so on.
</p><p>It is clear from this discussion that there always exists at least one valid Cartesian tree for any given sequence.
</p>
<h3><span class="mw-headline" id="Uniqueness">Uniqueness</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Cartesian_tree&amp;action=edit&amp;section=2" title="Edit section: Uniqueness">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Based on the technique given above to construct a Cartesian tree, and the underlying reasoning, we see that the Cartesian tree of a sequence of distinct numbers is always unique. If there are duplicates in the sequence, there may be multiple possible Cartesian trees; for example, the sequence [5, 5] has two possible Cartesian trees (one in which the root has a left child, and one in which it has a right child). On the other hand, [5, 2, 5] has only one possible Cartesian tree, even though it has duplicate elements. The precise criterion is that <i>the Cartesian tree is unique if and only if every segment of the sequence has a unique minimum element</i>.
</p><p>We can guarantee uniqueness even with duplicates by insisting that if an element appears multiple times in a sequence then the occurrence furthest to the left is always considered to be the smallest, or by finding any other way to break ties.
</p>
<h3><span class="mw-headline" id="Naive_method">Naive method</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Cartesian_tree&amp;action=edit&amp;section=3" title="Edit section: Naive method">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The naive method described above may take up to <img class="mwe-math-fallback-image-inline tex" alt="O(N^2)" src="/wiki/images/math/f/c/f/fcfcbd130c01389717669e8a2772703b.png" /> time, since it requires scanning the sequence to find its minimum, then scanning the range to the left of the minimum, and scanning the range to the right, and so on down; this algorithm then has the same performance dynamics as <a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;redlink=1" class="new" title="Quicksort (page does not exist)">quicksort</a> (average <img class="mwe-math-fallback-image-inline tex" alt="O(N \log N)" src="/wiki/images/math/6/c/2/6c2e9feb68e08f18ea437bca3531293e.png" />).
</p>
<h3><span class="mw-headline" id="Left-to-right">Left-to-right</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Cartesian_tree&amp;action=edit&amp;section=4" title="Edit section: Left-to-right">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The Cartesian tree may be constructed on one pass over the sequence. We proceed from left to right and add each value we encounter as a new node to the tree; after having processed the first <img class="mwe-math-fallback-image-inline tex" alt="i" src="/wiki/images/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png" /> elements of the sequence, we will have a valid Cartesian tree for these initial elements. After we have processed the entire sequence (<img class="mwe-math-fallback-image-inline tex" alt="i = N" src="/wiki/images/math/7/8/5/785592fbdaa4f44196f0b3dbfd478808.png" />), the Cartesian tree will be complete.
</p><p>Thus, we begin by constructing a singleton tree containing only the first element <img class="mwe-math-fallback-image-inline tex" alt="a_1" src="/wiki/images/math/8/e/6/8e6ba967645c302e1f2a60ec9c341e5c.png" /> in the sequence; this is a valid Cartesian tree for the segment of the sequence containing only the first element. Then, we repeatedly examine the next element <img class="mwe-math-fallback-image-inline tex" alt="a_{i+1}" src="/wiki/images/math/7/c/4/7c43f0dd11f1b20c83e8bd244c057caf.png" />. At each step, we keep track of <img class="mwe-math-fallback-image-inline tex" alt="v_i" src="/wiki/images/math/f/0/e/f0e66f55342ef85ba8be3415dd92d8e2.png" />, that is, the node that has label <img class="mwe-math-fallback-image-inline tex" alt="a_i" src="/wiki/images/math/d/8/d/d8dd7d0f3eb7145ca41c711457b7eb8f.png" /> (the last value inserted):
</p>
<ul><li> If <img class="mwe-math-fallback-image-inline tex" alt="a_{i+1} &gt; a_i" src="/wiki/images/math/9/a/2/9a2f31cf1839a34f70210e3ae0ee10ce.png" />, then we just insert a new node <img class="mwe-math-fallback-image-inline tex" alt="v_{i+1}" src="/wiki/images/math/6/f/3/6f340883dd21ccf289b8b5da1792f183.png" /> as the right child of <img class="mwe-math-fallback-image-inline tex" alt="v_i" src="/wiki/images/math/f/0/e/f0e66f55342ef85ba8be3415dd92d8e2.png" />, and label this new node with <img class="mwe-math-fallback-image-inline tex" alt="a_{i+1}" src="/wiki/images/math/7/c/4/7c43f0dd11f1b20c83e8bd244c057caf.png" />.</li>
<li> Otherwise, we consider node <img class="mwe-math-fallback-image-inline tex" alt="P(v_i)" src="/wiki/images/math/d/e/c/decdb8014673e53dc02b0958e3c8216b.png" />, the parent of <img class="mwe-math-fallback-image-inline tex" alt="v_i" src="/wiki/images/math/f/0/e/f0e66f55342ef85ba8be3415dd92d8e2.png" />. If the label of <img class="mwe-math-fallback-image-inline tex" alt="P(v_i)" src="/wiki/images/math/d/e/c/decdb8014673e53dc02b0958e3c8216b.png" /> is less than or equal to <img class="mwe-math-fallback-image-inline tex" alt="a_{i+1}" src="/wiki/images/math/7/c/4/7c43f0dd11f1b20c83e8bd244c057caf.png" />, we stop. Otherwise, we look to <i>its</i> parent, <img class="mwe-math-fallback-image-inline tex" alt="P(P(v_i))" src="/wiki/images/math/b/a/b/babe64d57b1e5ea78e06df86a514f971.png" />, and see whether <i>its</i> label is less than or equal to <img class="mwe-math-fallback-image-inline tex" alt="a_{i+1}" src="/wiki/images/math/7/c/4/7c43f0dd11f1b20c83e8bd244c057caf.png" /> and so on. If we stop at node <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />, with right child <img class="mwe-math-fallback-image-inline tex" alt="w" src="/wiki/images/math/f/1/2/f1290186a5d0b1ceab27f4e77c0c5d68.png" />, then we insert the new node <img class="mwe-math-fallback-image-inline tex" alt="v_{i+1}" src="/wiki/images/math/6/f/3/6f340883dd21ccf289b8b5da1792f183.png" /> so that it is the right child of <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />, and make <img class="mwe-math-fallback-image-inline tex" alt="w" src="/wiki/images/math/f/1/2/f1290186a5d0b1ceab27f4e77c0c5d68.png" /> the left child of <img class="mwe-math-fallback-image-inline tex" alt="v_{i+1}" src="/wiki/images/math/6/f/3/6f340883dd21ccf289b8b5da1792f183.png" />.</li>
<li> If we trace all the way up to the root of the tree so far, and still find no node with label less than or equal to <img class="mwe-math-fallback-image-inline tex" alt="a_{i+1}" src="/wiki/images/math/7/c/4/7c43f0dd11f1b20c83e8bd244c057caf.png" />, then <img class="mwe-math-fallback-image-inline tex" alt="a_{i+1}" src="/wiki/images/math/7/c/4/7c43f0dd11f1b20c83e8bd244c057caf.png" /> is the smallest element seen so far; so make the new node <img class="mwe-math-fallback-image-inline tex" alt="v_{i+1}" src="/wiki/images/math/6/f/3/6f340883dd21ccf289b8b5da1792f183.png" /> the root of the tree, and make the old root <img class="mwe-math-fallback-image-inline tex" alt="v_{i+1}" src="/wiki/images/math/6/f/3/6f340883dd21ccf289b8b5da1792f183.png" />'s left child.</li></ul>
<h4><span class="mw-headline" id="Pseudocode">Pseudocode</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Cartesian_tree&amp;action=edit&amp;section=5" title="Edit section: Pseudocode">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<pre>input sequence A with length N indexed from 1
// label the root node 1, with left child = right child = 0 (nonexistent)
root &#8592; 1
left[1] &#8592; 0
right[1] &#8592; 0
// the root's label is the first item in the sequence
label[1] &#8592; A[1]
for i &#8712; [2..N]
    last &#8592; i-1               // node of A[i-1]
    // create new node with label A[i]
    label[i] &#8592; A[i]
    right[i] &#8592; 0
    while label[last] &gt; A[i] and last &#8800; root
        last &#8592; parent[last]
    if label[last] &gt; A[i]    // A[i] is the smallest element yet; make it new root
        parent[root] &#8592; i
        left[i] &#8592; root
        root &#8592; i
    else if right[last] = 0       // just insert it
        right[last] &#8592; i
        parent[i] &#8592; last
        left[i] &#8592; 0
    else                     // reconfigure links
        parent[right[last]] &#8592; i
        left[i] &#8592; right[last]
        right[last] &#8592; i
        parent[i] &#8592; last
</pre>
<h4><span class="mw-headline" id="Proof_of_correctness">Proof of correctness</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Cartesian_tree&amp;action=edit&amp;section=6" title="Edit section: Proof of correctness">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>We define our invariant is as follows: <i>After the loop in the above algorithm has run <img class="mwe-math-fallback-image-inline tex" alt="m" src="/wiki/images/math/6/f/8/6f8f57715090da2632453988d9a1501b.png" /> times, we will have a valid Cartesian tree for the first <img class="mwe-math-fallback-image-inline tex" alt="m+1" src="/wiki/images/math/c/2/a/c2ae2329632cc86715f8a4de7a056880.png" /> elements of <code>A</code></i>.
</p><p>This is true just before the loop runs for the first time (<img class="mwe-math-fallback-image-inline tex" alt="m = 0" src="/wiki/images/math/e/6/7/e6753e61990bc639ae1869683cb421b7.png" />), because we will have a singleton tree that contains just the first element of <img class="mwe-math-fallback-image-inline tex" alt="A" src="/wiki/images/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png" />, and clearly this is a valid Cartesian tree for just that first element.
</p><p>Now assume the loop has completed <img class="mwe-math-fallback-image-inline tex" alt="m" src="/wiki/images/math/6/f/8/6f8f57715090da2632453988d9a1501b.png" /> iterations, but has not yet begun iteration <img class="mwe-math-fallback-image-inline tex" alt="m+1" src="/wiki/images/math/c/2/a/c2ae2329632cc86715f8a4de7a056880.png" />. Then, we have a valid Cartesian tree of the first <img class="mwe-math-fallback-image-inline tex" alt="m+1" src="/wiki/images/math/c/2/a/c2ae2329632cc86715f8a4de7a056880.png" /> elements of <img class="mwe-math-fallback-image-inline tex" alt="A" src="/wiki/images/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png" />, and we wish to insert <img class="mwe-math-fallback-image-inline tex" alt="A_{m+2}" src="/wiki/images/math/e/b/e/ebe9765dfacf960b1438191e102d7a9d.png" />. We first observe the following:
</p>
<ul><li> The last node inserted, which we will call <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" />, has no right child. This is because <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> must come last in the inorder traversal of the tree so far, as that tree is a valid Cartesian tree of all the elements added so far; but if <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> has a right child, then <img class="mwe-math-fallback-image-inline tex" alt="\mathrm{right}[v]" src="/wiki/images/math/0/8/e/08eff45978879967de09cdb23a9f8e98.png" /> will follow <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> in the inorder traversal.</li>
<li> <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> is the right child of <img class="mwe-math-fallback-image-inline tex" alt="\mathrm{parent}[v]" src="/wiki/images/math/8/1/9/819ed018d1f995dbb584a19f6a0dd5e7.png" />, if the latter exists. <img class="mwe-math-fallback-image-inline tex" alt="\mathrm{parent}[v]" src="/wiki/images/math/8/1/9/819ed018d1f995dbb584a19f6a0dd5e7.png" /> is furthermore the right child of <img class="mwe-math-fallback-image-inline tex" alt="\mathrm{parent}[\mathrm{parent}[v]]" src="/wiki/images/math/5/e/3/5e3c1e50edceaa4555baa1e08416e5ad.png" />, and so on all the way up to the root. If this were not the case, then <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> would lie in the left subtree of some node <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />, and therefore <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> would follow <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> in the inorder traversal, a contradiction.</li></ul>
<p>Then consider the three cases covered in the code:
</p>
<ol><li> If <img class="mwe-math-fallback-image-inline tex" alt="A_{m+2}" src="/wiki/images/math/e/b/e/ebe9765dfacf960b1438191e102d7a9d.png" /> is less than the label of the tree's root, then after we make it the new root (with the old root as its left child), <img class="mwe-math-fallback-image-inline tex" alt="A_{m+2}" src="/wiki/images/math/e/b/e/ebe9765dfacf960b1438191e102d7a9d.png" /> will occur at the very end of the inorder traversal, since everything in the left subtree will be visited before it; but the order in which the previously inserted elements are visited will be unchanged. Also, since <img class="mwe-math-fallback-image-inline tex" alt="A_{m+2}" src="/wiki/images/math/e/b/e/ebe9765dfacf960b1438191e102d7a9d.png" /> is the smallest element in the tree, and it goes at the root, the tree maintains its min-heap-ordering property. Hence the invariant is preserved.</li>
<li> If <img class="mwe-math-fallback-image-inline tex" alt="A_{m+2} \geq A_{m+1}" src="/wiki/images/math/6/3/b/63b14c16eaaf94d8fdb5311d2385772c.png" />, then after we have inserted a new node as the right child of <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" />, this node will follow <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> in the inorder traversal, but the order in which all other elements are visited will be unchanged, so the effect is to append the new node to the end of the inorder traversal of the old tree. The new tree will also maintain its min=heap-ordering, since the new node inserted is greater than or equal to its parent. Therefore, the invariant is preserved.</li>
<li> If we find some proper ancestor <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> of the most recently inserted node, whose label is less than or equal to <img class="mwe-math-fallback-image-inline tex" alt="A_{m+2}" src="/wiki/images/math/e/b/e/ebe9765dfacf960b1438191e102d7a9d.png" />, but whose right child's label is greater than <img class="mwe-math-fallback-image-inline tex" alt="A_{m+2}" src="/wiki/images/math/e/b/e/ebe9765dfacf960b1438191e102d7a9d.png" />, then <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> is visited immediately before all the elements in its right subtree, and those elements occur at the very end of the inorder traversal (since <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> is descended from the root of the tree along only right edges); furthermore all the elements in <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />'s right subtree are greater than or equal to the label of <img class="mwe-math-fallback-image-inline tex" alt="\mathrm{right}[u]" src="/wiki/images/math/6/3/d/63df7051424163b65d2f44dcc5e4661e.png" />. Now then, when we insert a new node as <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />'s right child, and make the original right child of <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> the left child of the new root, we see that all the elements formerly in <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />'s right subtree remain in <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />'s right subtree, that they are visited after <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> in the inorder traversal and all consecutively, and that the new node is visited at the very end; we conclude that the inorder traversal of the new tree is just the inorder traversal of the old tree with the new node visited at the very end. Also, since <img class="mwe-math-fallback-image-inline tex" alt="A_{m+2}" src="/wiki/images/math/e/b/e/ebe9765dfacf960b1438191e102d7a9d.png" /> is greater than or equal to <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />'s label, the min-heap-ordering is preserved at <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />; and since it is less than the label of <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />'s original right child, the min-heap-ordering is preserved here as well; so finally we conclude that the invariant is preserved. <img class="mwe-math-fallback-image-inline tex" alt="_{\blacksquare}" src="/wiki/images/math/7/1/b/71bd29496761f73ac935924fd05288c3.png" /></li></ol>
<h4><span class="mw-headline" id="Analysis_of_running_time">Analysis of running time</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Cartesian_tree&amp;action=edit&amp;section=7" title="Edit section: Analysis of running time">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Observe that the loop in the algorithm given above performs at most a constant number of operations per iteration, plus some variable number of operations possibly spent ascending the tree looking for a place to insert the new element. Now define the <i>active point</i> of the tree to be the node pointed to by the <code>last</code> variable. Every time we ascend the tree by one node, we decrease the active point's depth by one. Then, either Case 1, Case 2, or Case 3 happens. In Case 1, the active point's depth is left unchanged, as it goes from being the old tree's root to being the new tree's root. In Cases 2 and 3, the active point's depth increases by one, since the new node inserted is one level deeper than its parent (the previous active point), and this new node becomes the new active point. So in total the depth of the active node cannot increase more than <img class="mwe-math-fallback-image-inline tex" alt="N-1" src="/wiki/images/math/5/b/1/5b1ba2fe7e642d05d58d3df27466b069.png" /> times, once for each iteration of the loop. This means that it cannot decrease more than <img class="mwe-math-fallback-image-inline tex" alt="N-1" src="/wiki/images/math/5/b/1/5b1ba2fe7e642d05d58d3df27466b069.png" /> times in total, either, because it starts at 0 and must finish as a non-negative integer. Hence the total number of times we ascend the tree is <img class="mwe-math-fallback-image-inline tex" alt="O(N)" src="/wiki/images/math/3/3/6/33697ce7dfa48ba80980d298c8089378.png" /> across all iterations of the loop, and all the other loop operations take <img class="mwe-math-fallback-image-inline tex" alt="O(N)" src="/wiki/images/math/3/3/6/33697ce7dfa48ba80980d298c8089378.png" /> time total, so the construction is completed in <img class="mwe-math-fallback-image-inline tex" alt="O(N)" src="/wiki/images/math/3/3/6/33697ce7dfa48ba80980d298c8089378.png" /> time. (This analysis also shows that each of the iterations of the loop uses amortized constant time.)
</p>
<h3><span class="mw-headline" id="Using_all_nearest_smaller_values">Using all nearest smaller values</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Cartesian_tree&amp;action=edit&amp;section=8" title="Edit section: Using all nearest smaller values">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Another construction method relies on finding <a href="/wiki/All_nearest_smaller_values" title="All nearest smaller values">all nearest smaller values</a> of the sequence, which can be done in linear time. That is, for each element <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> in the sequence, we find the maximum <img class="mwe-math-fallback-image-inline tex" alt="j &lt; i" src="/wiki/images/math/e/0/0/e00a1cf3e30f9cdfe98fa86474f38b9f.png" /> such that <img class="mwe-math-fallback-image-inline tex" alt="A_j \leq A_i" src="/wiki/images/math/8/b/2/8b2c68c92f6312458280d6188025ddcd.png" />; this is the <i>nearest smaller value on the left</i> (LNSV) . We also find the minimum <img class="mwe-math-fallback-image-inline tex" alt="k &gt; i" src="/wiki/images/math/9/f/0/9f0c3a4090560285e8a1957b337945e5.png" /> such that <img class="mwe-math-fallback-image-inline tex" alt="A_k &lt; A_i" src="/wiki/images/math/b/7/5/b7598fae28a0f18e07a0c2e4206116dc.png" />, and call this the <i>nearest smaller value on the right</i> (RNSV).
</p><p><i>Theorem</i>: Consider the unique Cartesian tree of <img class="mwe-math-fallback-image-inline tex" alt="A" src="/wiki/images/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png" /> obtained by considering the first of equal elements to be the smallest. (In such a tree, if node with label <img class="mwe-math-fallback-image-inline tex" alt="x" src="/wiki/images/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png" /> has a left child with label <img class="mwe-math-fallback-image-inline tex" alt="l" src="/wiki/images/math/2/d/b/2db95e8e1a9267b7a1188556b2013b33.png" />, then <img class="mwe-math-fallback-image-inline tex" alt="l &lt; x" src="/wiki/images/math/5/b/e/5be727a035722ee17da9dfe3852aa9d6.png" />, and if it has a right child with label <img class="mwe-math-fallback-image-inline tex" alt="r" src="/wiki/images/math/4/b/4/4b43b0aee35624cd95b910189b3dc231.png" />, then <img class="mwe-math-fallback-image-inline tex" alt="r \leq x" src="/wiki/images/math/4/7/7/477b69633af436cf8d70aff68e81e190.png" />.) Then, given an element <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> of the sequence, excepting that it is the root of the tree, it will be either the LNSV's right child or the RNSV's left child, as determined by the following rules:
</p>
<ol><li> If the LNSV and RNSV both exist, the larger of the two is the parent of <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> in the tree. In case of a tie, the RNSV wins.</li>
<li> If only the LSNV exists, it is <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" />'s parent. If only the RNSV exists, it is <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" />'s parent.</li>
<li> If neither the LNSV nor the RNSV exists, <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> is the root.</li></ol>
<p><i>Proof</i>: Suppose that node labelled <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> is the right child of its parent. Then its parent must be labelled <img class="mwe-math-fallback-image-inline tex" alt="A_j" src="/wiki/images/math/8/7/a/87a72a8622edcb5195a0e10778f77f97.png" /> where <img class="mwe-math-fallback-image-inline tex" alt="j &lt; i" src="/wiki/images/math/e/0/0/e00a1cf3e30f9cdfe98fa86474f38b9f.png" />, because <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> occurs <i>after</i> <img class="mwe-math-fallback-image-inline tex" alt="A_j" src="/wiki/images/math/8/7/a/87a72a8622edcb5195a0e10778f77f97.png" /> in the inorder traversal. Also, <img class="mwe-math-fallback-image-inline tex" alt="A_i \geq A_j" src="/wiki/images/math/d/6/4/d64e7bd96094c1996c9a758bdd7e43bc.png" />. Now suppose there exists <img class="mwe-math-fallback-image-inline tex" alt="k" src="/wiki/images/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png" /> such that <img class="mwe-math-fallback-image-inline tex" alt="j &lt; k &lt; i" src="/wiki/images/math/5/7/f/57fd6f79dc7543757125a4639c342270.png" /> and <img class="mwe-math-fallback-image-inline tex" alt="A_i \geq A_k" src="/wiki/images/math/b/e/4/be414ae0b3cbec0b929b77f9e919b367.png" /> (that is, <img class="mwe-math-fallback-image-inline tex" alt="A_j" src="/wiki/images/math/8/7/a/87a72a8622edcb5195a0e10778f77f97.png" /> is not the LNSV to <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" />). Then, <img class="mwe-math-fallback-image-inline tex" alt="A_k" src="/wiki/images/math/d/9/3/d93f57d24bbe3378bf1116d752877d4f.png" /> must occur <i>after</i> <img class="mwe-math-fallback-image-inline tex" alt="A_j" src="/wiki/images/math/8/7/a/87a72a8622edcb5195a0e10778f77f97.png" /> in the inorder traversal, but <i>before</i> <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" />. This is only possible if <img class="mwe-math-fallback-image-inline tex" alt="A_k" src="/wiki/images/math/d/9/3/d93f57d24bbe3378bf1116d752877d4f.png" /> occurs in the left subtree of the node labelled <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" />. However, this implies that <img class="mwe-math-fallback-image-inline tex" alt="A_k &gt; A_i" src="/wiki/images/math/e/7/9/e79a60c5f36873109ae8980fdadbefb5.png" />, a contradiction. A similar analysis shows that if <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" />'s parent occurs after <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> in the sequence <img class="mwe-math-fallback-image-inline tex" alt="A" src="/wiki/images/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png" />, it must be the RNSV of <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" />. Now, pursuant to the three cases in the statement of the Theorem:
</p>
<ol><li> Since the LNSV and RNSV exist, node labelled <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> is not the root. Therefore this node has a parent. The foregoing analysis shows that if node labelled <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> is the right child of its parent, then the parent is labelled with the LSNV, and if it is the left child, the parent is labelled with the RNSV. Suppose the former is true and <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" />'s parent is its LNSV. Then the RNSV follows <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> and <img class="mwe-math-fallback-image-inline tex" alt="A_j" src="/wiki/images/math/8/7/a/87a72a8622edcb5195a0e10778f77f97.png" /> in the inorder traversal. However, it cannot be in the right subtree of node labelled <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" />, since its value is strictly less than <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" />. It follows that it cannot be anywhere in the right subtree of <img class="mwe-math-fallback-image-inline tex" alt="A_j" src="/wiki/images/math/8/7/a/87a72a8622edcb5195a0e10778f77f97.png" /> either (or anywhere in the subtree rooted at <img class="mwe-math-fallback-image-inline tex" alt="A_j" src="/wiki/images/math/8/7/a/87a72a8622edcb5195a0e10778f77f97.png" />). Now let <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> be the lowest common ancestor of the nodes labelled with <img class="mwe-math-fallback-image-inline tex" alt="A_j" src="/wiki/images/math/8/7/a/87a72a8622edcb5195a0e10778f77f97.png" /> and the RNSV. If <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> <i>is</i> the node labelled with the RNSV, then node labelled <img class="mwe-math-fallback-image-inline tex" alt="A_j" src="/wiki/images/math/8/7/a/87a72a8622edcb5195a0e10778f77f97.png" /> is in the RNSV's left subtree, which means <img class="mwe-math-fallback-image-inline tex" alt="A_j" src="/wiki/images/math/8/7/a/87a72a8622edcb5195a0e10778f77f97.png" /> (the LNSV) is strictly greater than the RNSV, as desired. If not, then since the RNSV occurs after <img class="mwe-math-fallback-image-inline tex" alt="A_j" src="/wiki/images/math/8/7/a/87a72a8622edcb5195a0e10778f77f97.png" /> in the inorder traversal, it must be that the RNSV is in <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />'s right subtree and node labelled <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> is in <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />'s left subtree. But then <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> occurs after <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> in the inorder traversal and before the RNSV, and <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />'s label is strictly less than <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" />, which contradicts the "nearestness" of the supposed RNSV (so this case can never occur at all). A similar analysis shows that if node labelled <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> is the left child of its parent, then the parent is labelled with the RNSV and the RNSV is greater than or equal to the LNSV, as desired.</li>
<li> If only the LSNV exists, then node labelled <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> still cannot be the root, but all the elements following <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> are greater than or equal to it, so node labelled <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> cannot be the left child of any node. Therefore it is the right child of its parent, and therefore its parent is the LNSV. Likewise, if only the RNSV exists, we see that node labelled <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> is the left child of its parent, and thus the parent must be the RNSV.</li>
<li> If neither the LSNV nor the RNSV exists, then <img class="mwe-math-fallback-image-inline tex" alt="A_i" src="/wiki/images/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png" /> is the leftmost occurrence of the minimum element in the sequence, and hence must be at the root of the tree. <img class="mwe-math-fallback-image-inline tex" alt="_{\blacksquare}" src="/wiki/images/math/7/1/b/71bd29496761f73ac935924fd05288c3.png" /></li></ol>
<p>Using the preceding Theorem, after computing all nearest smaller values on both sides of each element (which requires linear time), we can determine each node's parent in constant time, so we obtain overall linear time construction.
</p>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Cartesian_tree&amp;action=edit&amp;section=9" title="Edit section: Applications">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li> A <a href="/wiki/Range_minimum_query" title="Range minimum query">range minimum query</a> on a sequence is equivalent to a <a href="/wiki/Lowest_common_ancestor" title="Lowest common ancestor">lowest common ancestor</a> query on the sequence's Cartesian tree. Hence, RMQ may be reduced to LCA using the sequence's Cartesian tree.</li>
<li> The <a href="/wiki/index.php?title=Treap&amp;action=edit&amp;redlink=1" class="new" title="Treap (page does not exist)">treap</a>, a <a href="/wiki/index.php?title=Balanced_binary_search_tree&amp;action=edit&amp;redlink=1" class="new" title="Balanced binary search tree (page does not exist)">balanced binary search tree</a> structure, is a Cartesian tree of (key,priority) pairs; it is heap-ordered according to the priority values, and an inorder traversal gives the keys in sorted order.</li>
<li> The suffix tree of a string may be constructed from the <a href="/wiki/index.php?title=Suffix_array&amp;action=edit&amp;redlink=1" class="new" title="Suffix array (page does not exist)">suffix array</a> and the <a href="/wiki/index.php?title=Longest_common_prefix_array&amp;action=edit&amp;redlink=1" class="new" title="Longest common prefix array (page does not exist)">longest common prefix array</a>. The first step is to compute the Cartesian tree of the longest common prefix array. Details in the <a href="/wiki/index.php?title=Suffix_tree&amp;action=edit&amp;redlink=1" class="new" title="Suffix tree (page does not exist)">Suffix tree</a> article.</li></ul>

<!-- 
NewPP limit report
CPU time usage: 0.148 seconds
Real time usage: 0.167 seconds
Preprocessor visited node count: 1340/1000000
Preprocessor generated node count: 2940/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:413-0!*!0!!en!5!*!math=0 and timestamp 20180417004921 and revision id 2000
 -->
</div>									<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://wcipeg.com/wiki/index.php?title=Cartesian_tree&amp;oldid=2000">https://wcipeg.com/wiki/index.php?title=Cartesian_tree&amp;oldid=2000</a>"					</div>
													<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="/wiki/Category:Trees" title="Category:Trees">Trees</a></li><li><a href="/wiki/Category:Data_structures" title="Category:Data structures">Data structures</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-createaccount"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Cartesian+tree&amp;type=signup" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li><li id="pt-login"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Cartesian+tree" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
															<li  id="ca-nstab-main" class="selected"><span><a href="/wiki/Cartesian_tree"  title="View the content page [c]" accesskey="c">Page</a></span></li>
															<li  id="ca-talk" class="new"><span><a href="/wiki/index.php?title=Talk:Cartesian_tree&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a href="/wiki/Cartesian_tree" >Read</a></span></li>
															<li id="ca-edit"><span><a href="/wiki/index.php?title=Cartesian_tree&amp;action=edit"  title="You can edit this page. Please use the preview button before saving [e]" accesskey="e">Edit</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="/wiki/index.php?title=Cartesian_tree&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>

						<form action="/wiki/index.php" id="searchform">
														<div id="simpleSearch">
															<input type="search" name="search" placeholder="Search" title="Search PEGWiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />								</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="/wiki/Main_Page"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
			<h3 id='p-navigation-label'>Navigation</h3>

			<div class="body">
									<ul>
													<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
													<li id="n-Index"><a href="/wiki/Special:AllPages">Index</a></li>
													<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
													<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
													<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
			<h3 id='p-tb-label'>Tools</h3>

			<div class="body">
									<ul>
													<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Cartesian_tree" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
													<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Cartesian_tree" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
													<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
													<li id="t-print"><a href="/wiki/index.php?title=Cartesian_tree&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
													<li id="t-permalink"><a href="/wiki/index.php?title=Cartesian_tree&amp;oldid=2000" title="Permanent link to this revision of the page">Permanent link</a></li>
													<li id="t-info"><a href="/wiki/index.php?title=Cartesian_tree&amp;action=info" title="More information about this page">Page information</a></li>
											</ul>
							</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 13 June 2016, at 18:02.</li>
											<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by/3.0/">Attribution 3.0 Unported</a> unless otherwise noted.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="/wiki/PEGWiki:Privacy_policy" title="PEGWiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/wiki/PEGWiki:About" title="PEGWiki:About">About PEGWiki</a></li>
											<li id="footer-places-disclaimer"><a href="/wiki/PEGWiki:General_disclaimer" title="PEGWiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
															<a href="http://creativecommons.org/licenses/by/3.0/"><img src="http://i.creativecommons.org/l/by/3.0/88x31.png" alt="Attribution 3.0 Unported" width="88" height="31" /></a>
													</li>
											<li id="footer-poweredbyico">
															<a href="//www.mediawiki.org/"><img src="/wiki/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/wiki/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /wiki/resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" /></a>
													</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>if(window.jQuery)jQuery.ready();</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.toc","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"https://wcipeg.com/wiki/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=vector\u0026amp;*\"\u003E\u003C/script\u003E");
}</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":91});
}</script>
	</body>
</html>
