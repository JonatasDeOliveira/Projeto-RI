<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" />
<title>Shortest path - PEGWiki</title>
<meta name="generator" content="MediaWiki 1.25.2" />
<link rel="alternate" type="application/x-wiki" title="Edit" href="/wiki/index.php?title=Shortest_path&amp;action=edit" />
<link rel="edit" title="Edit" href="/wiki/index.php?title=Shortest_path&amp;action=edit" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/wiki/opensearch_desc.php" title="PEGWiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://wcipeg.com/wiki/api.php?action=rsd" />
<link rel="alternate" hreflang="x-default" href="/wiki/Shortest_path" />
<link rel="copyright" href="http://creativecommons.org/licenses/by/3.0/" />
<link rel="alternate" type="application/atom+xml" title="PEGWiki Atom feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=ext.math.styles%7Cext.rtlcite%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wikidb:resourceloader:filter:minify-css:7:b36fd1c042133c9c9b60260f7c29b237 */</style>
<script src="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Shortest_path","wgTitle":"Shortest path","wgCurRevisionId":1329,"wgRevisionId":1329,"wgArticleId":117,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Shortest_path","wgRelevantArticleId":117,"wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});});
/* cache key: wikidb:resourceloader:filter:minify-js:7:a5c52c063dc436c1ca7c9f456936a5e9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/wiki/skins/Vector/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Shortest_path skin-vector action-view">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

						<div class="mw-indicators">
</div>
			<h1 id="firstHeading" class="firstHeading" lang="en">Shortest path</h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">From PEGWiki</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>The <b>shortest paths</b> problem is one of the most fundamental problems in <a href="/wiki/Graph_theory" title="Graph theory">graph theory</a>. Given a directed graph <img class="mwe-math-fallback-image-inline tex" alt="G = (V,E)" src="/wiki/images/math/9/e/9/9e9992d6bf50b7580f971487c466a8cb.png" />, possibly weighted, and a set of pairs of vertices <img class="mwe-math-fallback-image-inline tex" alt="\{(u_1,v_1), ..., (u_n,v_n)\}, u_i, v_i \in V" src="/wiki/images/math/3/6/b/36b0368a24b144139feb72366488329f.png" />, the problem is to compute, for each <img class="mwe-math-fallback-image-inline tex" alt="i" src="/wiki/images/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png" />, a <b>simple</b> path in <img class="mwe-math-fallback-image-inline tex" alt="G" src="/wiki/images/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png" /> from <img class="mwe-math-fallback-image-inline tex" alt="u_i" src="/wiki/images/math/2/4/d/24d83a37508452537d66cff51c78d168.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v_i" src="/wiki/images/math/f/0/e/f0e66f55342ef85ba8be3415dd92d8e2.png" /> (a list of vertices <img class="mwe-math-fallback-image-inline tex" alt="u_i = s_{i,0}, s_{i,1}, ..., s_{i,k} = v_i" src="/wiki/images/math/f/4/b/f4b00d1541ce5e60e51a4812d8f78c05.png" /> such that for all <img class="mwe-math-fallback-image-inline tex" alt="0 \leq j &lt; k" src="/wiki/images/math/6/d/c/6dcd7f1943141c0d6cbc330b1d39915f.png" />, <img class="mwe-math-fallback-image-inline tex" alt="(s_{i,j},s_{i,j+1}) \in E" src="/wiki/images/math/5/b/9/5b9da6eea10d0c584b280af595d7ce09.png" />) such that no other simple path in <img class="mwe-math-fallback-image-inline tex" alt="G" src="/wiki/images/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png" /> from <img class="mwe-math-fallback-image-inline tex" alt="u_i" src="/wiki/images/math/2/4/d/24d83a37508452537d66cff51c78d168.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v_i" src="/wiki/images/math/f/0/e/f0e66f55342ef85ba8be3415dd92d8e2.png" /> has a lower total weight.
</p><p>Shortest paths in undirected graphs can be computed by replacing each undirected edge with two arcs of the same weight, one going in each direction, to obtain a directed graph.
</p><p><b>Theorem</b>: In a graph with no cycles of negative weight, the shortest path is no shorter than the shortest simple path. (On the other hand, in a graph with a negative-weight cycle, lengths of paths may be unbounded below.)
</p><p><b>Proof</b>: We show that any path from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> can be transformed into a simple path from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> which is at least as short. Let the path be denoted <img class="mwe-math-fallback-image-inline tex" alt="[u = s_0, s_1, ..., s_j = v]" src="/wiki/images/math/6/8/6/686eea80a554ea2def3daa7aae0e81d4.png" />. We proceed by induction on the number of pairs <img class="mwe-math-fallback-image-inline tex" alt="(i,j)" src="/wiki/images/math/5/2/7/5270ae675fac24f97e172dcd9b18fa92.png" /> (with <img class="mwe-math-fallback-image-inline tex" alt="i \neq j" src="/wiki/images/math/3/d/2/3d27367ea16a2a7b40b3eb3172a32120.png" />) such that <img class="mwe-math-fallback-image-inline tex" alt="s_i = s_j" src="/wiki/images/math/5/a/8/5a88e2b7a650895bebac9d0bdf016997.png" />, which is countable. When there are zero such pairs, the path is already simple, and nothing needs to be done. Otherwise, we transform the path into another path with fewer such pairs but equal or lesser weight by removing the vertices <img class="mwe-math-fallback-image-inline tex" alt="s_i, s_{i+1}, ..., s_{j-1}" src="/wiki/images/math/d/6/d/d6d5a310b02711b9959a2a59aa9ebeea.png" /> from the path. The weight of the path therefore decreases by an amount equal to the weight of the cycle <img class="mwe-math-fallback-image-inline tex" alt="s_i, s_{i+1}, ..., s_j = s_i" src="/wiki/images/math/c/7/f/c7f9c0ee6fbde86eb4f838ce65cb6dd0.png" />, which is nonnegative. <img class="mwe-math-fallback-image-inline tex" alt="_\blacksquare" src="/wiki/images/math/7/7/3/773d97c085dfd2ddd2d1d170ff65aa2e.png" />
</p><p><b>Corollary</b>: Assuming our graphs have no cycles of negative weight, the restriction that the shortest paths be simple is immaterial. Therefore, we will assume in the foregoing discussion that our graphs have no cycles of negative weight, for the problem of finding shortest <i>simple</i> paths in graphs containing negative-weight cycles is NP-complete.
</p><p><b>Corollary</b>: In a finite connected graph, a shortest path always exists. (To prove this we simply use the fact that the graph has a finite number of simple paths, and only simple paths need be considered. So one of them must be the shortest.)
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Variations"><span class="tocnumber">1</span> <span class="toctext">Variations</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Approach"><span class="tocnumber">2</span> <span class="toctext">Approach</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Relaxation"><span class="tocnumber">2.1</span> <span class="toctext">Relaxation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Single-source_shortest_paths"><span class="tocnumber">3</span> <span class="toctext">Single-source shortest paths</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#All-pairs_shortest_paths"><span class="tocnumber">4</span> <span class="toctext">All-pairs shortest paths</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Single-pair_shortest_path"><span class="tocnumber">5</span> <span class="toctext">Single-pair shortest path</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="#A.2A_or_heuristic_search"><span class="tocnumber">5.1</span> <span class="toctext">A* or heuristic search</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Meet-in-the-middle"><span class="tocnumber">5.2</span> <span class="toctext">Meet-in-the-middle</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Variations">Variations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Shortest_path&amp;action=edit&amp;section=1" title="Edit section: Variations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Three variations of the shortest path algorithm exist, and they are discussed in the following sections.
</p>
<ul><li> In the <i>single-pair shortest path</i> problem, there is only one pair <img class="mwe-math-fallback-image-inline tex" alt="(u,v)" src="/wiki/images/math/9/0/9/9093cc72d2d40694b9361424cb0a6803.png" /> in the problem set. In other words the shortest path is desired between a single pair of vertices.</li>
<li> In the <i>single-source shortest paths</i> problem, the problem set is of the form <img class="mwe-math-fallback-image-inline tex" alt="\{u\} \times V" src="/wiki/images/math/0/5/e/05e97b25dcab436009b74cbc394fa2ca.png" />. One vertex, <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />, is designated the <i>source</i>, and we wish to find the shortest paths from the source to all other vertices. (To solve the analogous <i>single-destination shortest paths</i> problem, we merely reverse the directions of all edges, which reduces it to single-source.)</li>
<li> In the <i>all-pairs shortest paths</i> problem, the problem set is <img class="mwe-math-fallback-image-inline tex" alt="V \times V" src="/wiki/images/math/4/7/2/472fb44578beb2a8e722fb1cc1c555ac.png" />; that is, we wish to know the shortest paths from every vertex to every other vertex.</li></ul>
<h2><span class="mw-headline" id="Approach">Approach</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Shortest_path&amp;action=edit&amp;section=2" title="Edit section: Approach">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>All the shortest paths algorithms discussed in this article have the same basic approach. At their core, they compute not the shortest paths themselves, but the distances. Using information computed in order to compute the distances, one can easily then reconstruct the paths themselves. They begin with the knowledge that the distance from any vertex to itself is zero, and they overestimate all other distances they need. (By this it is meant that they find a number <img class="mwe-math-fallback-image-inline tex" alt="d_{i,j}" src="/wiki/images/math/4/c/6/4c60c123f4b251056eda7c71cebfa6e8.png" /> for each pair <img class="mwe-math-fallback-image-inline tex" alt="(i,j)" src="/wiki/images/math/5/2/7/5270ae675fac24f97e172dcd9b18fa92.png" /> under consideration such that the distance from <img class="mwe-math-fallback-image-inline tex" alt="i" src="/wiki/images/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="j" src="/wiki/images/math/3/6/3/363b122c528f54df4a0446b6bab05515.png" /> is less than or equal to <img class="mwe-math-fallback-image-inline tex" alt="d_{i,j}" src="/wiki/images/math/4/c/6/4c60c123f4b251056eda7c71cebfa6e8.png" />.) If <img class="mwe-math-fallback-image-inline tex" alt="(i,j) \in E" src="/wiki/images/math/7/c/8/7c864e0319c78536a1316a1c14bf8486.png" />, then the initial overestimate for the distance from <img class="mwe-math-fallback-image-inline tex" alt="i" src="/wiki/images/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="j" src="/wiki/images/math/3/6/3/363b122c528f54df4a0446b6bab05515.png" /> is the weight of the edge <img class="mwe-math-fallback-image-inline tex" alt="(i,j)" src="/wiki/images/math/5/2/7/5270ae675fac24f97e172dcd9b18fa92.png" />; otherwise it is infinite. At some point, all overestimates will be refined, perhaps gradually, perhaps at once, so that once the algorithm has terminated, they are exactly the correct distances.
</p>
<h3><span class="mw-headline" id="Relaxation">Relaxation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Shortest_path&amp;action=edit&amp;section=3" title="Edit section: Relaxation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>There are theoretically many ways to refine overestimates but a specific way, known as <b>relaxation</b>, is used in all the algorithms discussed in this article. Relaxation can take place when three conditions are met:
</p>
<ol><li> The currently best overestimate for the distance from some vertex <img class="mwe-math-fallback-image-inline tex" alt="i" src="/wiki/images/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png" /> to some vertex <img class="mwe-math-fallback-image-inline tex" alt="k" src="/wiki/images/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png" /> is <img class="mwe-math-fallback-image-inline tex" alt="d_1" src="/wiki/images/math/9/7/5/975e82ee46300a50d901d66c00fe64b1.png" />;</li>
<li> The currently best overestimate for the distance from <img class="mwe-math-fallback-image-inline tex" alt="k" src="/wiki/images/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png" /> to some vertex <img class="mwe-math-fallback-image-inline tex" alt="j" src="/wiki/images/math/3/6/3/363b122c528f54df4a0446b6bab05515.png" /> is <img class="mwe-math-fallback-image-inline tex" alt="d_2" src="/wiki/images/math/2/6/e/26ee688d727ea0c771dbdf3f456895bd.png" />,</li>
<li> The currently best overestimate for the distance from <img class="mwe-math-fallback-image-inline tex" alt="i" src="/wiki/images/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="j" src="/wiki/images/math/3/6/3/363b122c528f54df4a0446b6bab05515.png" /> is greater than <img class="mwe-math-fallback-image-inline tex" alt="d_1+d_2" src="/wiki/images/math/6/8/7/6872bf6c24b8886c2b6defc03a73ff15.png" />. (This includes the case in which it is infinite.)</li></ol>
<p>Relaxation refines the best overestimate for the distance from <img class="mwe-math-fallback-image-inline tex" alt="i" src="/wiki/images/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="j" src="/wiki/images/math/3/6/3/363b122c528f54df4a0446b6bab05515.png" /> by setting it to <img class="mwe-math-fallback-image-inline tex" alt="d_1+d_2" src="/wiki/images/math/6/8/7/6872bf6c24b8886c2b6defc03a73ff15.png" />, which is better than its current value.
</p><p><b>Theorem</b>: When the distances from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to all other vertices are all overestimated, but no relaxations are possible, then those distances are all known correctly. Contrapositively, if at there exists <img class="mwe-math-fallback-image-inline tex" alt="v \in V" src="/wiki/images/math/f/5/9/f597bb2e018f9feb80df75d899613dbe.png" /> such that the distance from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> is not correctly known, then relaxation must be possible somewhere in the graph.
</p><p><b>Proof</b>: By induction on the number of edges in some shortest path from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> (which we can take to be simple). It is vacuously true when this is zero or one, because all paths of length zero or one were accounted for in the initial overestimates. Assume the path has at least two edges, and denote by <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> the last vertex on the path before <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" />. If the distance from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> or from <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> is not known, then by the inductive hypothesis, we are done. Otherwise, notice that the path contains two subpaths, one from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> and one from <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> (the latter is trivial as it consists of a single edge), and that each of these must itself be a shortest path, otherwise we could replace it with a shorter path to obtain a shorter path from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" />, a contradiction. Now, as the distances from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> and <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> are correctly known, and the correct distance from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> is exactly the sum of the distances from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> and <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> (as these values equal the weights of the aforementioned subpaths), and our overestimate of the distance from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> is incorrect, it must be strictly greater than the sum of the distances from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> and <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> to <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" />. Hence <img class="mwe-math-fallback-image-inline tex" alt="(u,v)" src="/wiki/images/math/9/0/9/9093cc72d2d40694b9361424cb0a6803.png" /> can be relaxed. <img class="mwe-math-fallback-image-inline tex" alt="_\blacksquare" src="/wiki/images/math/7/7/3/773d97c085dfd2ddd2d1d170ff65aa2e.png" />
</p>
<h2><span class="mw-headline" id="Single-source_shortest_paths">Single-source shortest paths</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Shortest_path&amp;action=edit&amp;section=4" title="Edit section: Single-source shortest paths">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In an unweighted graph, the single-source shortest paths may be determined by performing <a href="/wiki/Breadth-first_search" title="Breadth-first search">breadth-first search</a> from the source. This is correct by definition; breadth-first search visits nodes in increasing order of their distance from the start node, so that as soon as we visit a node, we immediately know the correct distance to this node. This is guaranteed to terminate after considering each edge at most twice (once from each end in an undirected graph), since we do not expand from nodes that have already been visited. It follows that the running time is <img class="mwe-math-fallback-image-inline tex" alt="O(E+V)" src="/wiki/images/math/2/6/7/267244aefef037f4a317c5b89632eb90.png" />. BFS also solves the problem when some edges are allowed to have weight zero (by using a <a href="/wiki/Deque" title="Deque">deque</a> in place of the <a href="/wiki/Queue" title="Queue">queue</a>).
</p><p>In a weighted graph with nonnegative weights, it is still possible to visit the vertices in increasing order of distance from the source. This is because the source is obviously the closest to itself, the next closest vertex is obviously one of its immediate neighbors, the next closest is obviously either another immediate neighbor of the source or an immediate neighbor of the second closest vertex, and so on --- the length of a path cannot decrease as more nodes are added to the end of it. So by replacing the queue with a <a href="/wiki/index.php?title=Priority_queue&amp;action=edit&amp;redlink=1" class="new" title="Priority queue (page does not exist)">priority queue</a> and greedily picking the next vertex to visit, we obtain <a href="/wiki/Dijkstra%27s_algorithm" title="Dijkstra's algorithm">Dijkstra's algorithm</a>, which is slower by only a log factor due to the priority queue, <img class="mwe-math-fallback-image-inline tex" alt="O((E+V)\log V)" src="/wiki/images/math/9/b/7/9b77c473c562f145cee62cd1530d27bf.png" /> overall in a finite graph. (In a dense graph, it is also possible to implement this in <img class="mwe-math-fallback-image-inline tex" alt="O(E+V^2)" src="/wiki/images/math/7/e/d/7ed9374160079ca8bc8f9fe45c1cc125.png" /> time, which is asymptotically optimal in this case.)
</p><p>If, on the other hand, edges of negative weight exist, but not in a way that introduces negative-weight cycles, there is still a simple way to find shortest paths, known as the <a href="/wiki/Bellman%E2%80%93Ford_algorithm" title="Bellman–Ford algorithm">Bellman–Ford algorithm</a>. This works by repeatedly trying to relax each edge in the graph; it is not too hard to show that after doing this enough times, the correct shortest paths will all be known. Specifically, <img class="mwe-math-fallback-image-inline tex" alt="V-1" src="/wiki/images/math/8/f/6/8f674257aac367d73f35eaccb9170388.png" /> iterations are required, so the running time is <img class="mwe-math-fallback-image-inline tex" alt="O(VE)" src="/wiki/images/math/8/c/0/8c027a5c7a221c5c2f990088f3652616.png" />. Another solution, which is sometimes faster, is the <a href="/wiki/Shortest_Path_Faster_Algorithm" title="Shortest Path Faster Algorithm">Shortest Path Faster Algorithm</a> (SPFA).
</p>
<h2><span class="mw-headline" id="All-pairs_shortest_paths">All-pairs shortest paths</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Shortest_path&amp;action=edit&amp;section=5" title="Edit section: All-pairs shortest paths">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>We might try to find all-pairs shortest paths by running a single-source shortest paths algorithm using each vertex in turn as the source. Hence, we have the following bounds with a <a href="/wiki/Binary_heap" title="Binary heap">binary heap</a> implementation of the <a href="/wiki/index.php?title=Priority_queue&amp;action=edit&amp;redlink=1" class="new" title="Priority queue (page does not exist)">priority queue</a> ADT:
</p>
<ul><li> <img class="mwe-math-fallback-image-inline tex" alt="O(V(E+V))" src="/wiki/images/math/1/8/e/18e937c811ab07cd37d0b5249e1fc5b3.png" /> when the graph is unweighted</li>
<li> <img class="mwe-math-fallback-image-inline tex" alt="O(V(E+V)\log V)" src="/wiki/images/math/c/6/9/c696953365afed2e38bf168826be5bd3.png" /> when the edge weights are nonnegative and the graph is sparse (<img class="mwe-math-fallback-image-inline tex" alt="O(V(E + \log V))" src="/wiki/images/math/0/3/2/0329bb2346ab697c6eabfcdd4decb2aa.png" /> using a <a href="/wiki/index.php?title=Fibonacci_heap&amp;action=edit&amp;redlink=1" class="new" title="Fibonacci heap (page does not exist)">Fibonacci heap</a>)</li>
<li> <img class="mwe-math-fallback-image-inline tex" alt="O(VE+V^3)" src="/wiki/images/math/6/f/f/6fff5727dd4b0a55106c0b9bf78bdebd.png" /> when the edge weights are nonnegative and the graph is dense</li>
<li> <img class="mwe-math-fallback-image-inline tex" alt="O(V^2E)" src="/wiki/images/math/5/3/2/5321e09d73abc9170644b976e32e4363.png" /> when edge weights are allowed to be negative, but no negative-weight cycles exist.</li></ul>
<p>There is also a general-purpose technique called the <a href="/wiki/Floyd%E2%80%93Warshall" title="Floyd–Warshall" class="mw-redirect">Floyd–Warshall</a> algorithm, which is often considered <a href="/wiki/Dynamic_programming" title="Dynamic programming">dynamic</a>, that solves all four cases in <img class="mwe-math-fallback-image-inline tex" alt="O(V^3)" src="/wiki/images/math/0/2/c/02cda53abdf42bc294ba50e81ace4a2c.png" /> time. It works by using each vertex in turn and using it to try to relax the distance between every pair of nodes in the graph. When the graph is dense, Floyd–Warshall is just as fast as BFS or Dijkstra's, and it always outperforms Bellman–Ford. So we have the bound <img class="mwe-math-fallback-image-inline tex" alt="O(V(E+V)\log V)" src="/wiki/images/math/c/6/9/c696953365afed2e38bf168826be5bd3.png" /> for sparse graphs with nonnegative edge weights and <img class="mwe-math-fallback-image-inline tex" alt="O(V^3)" src="/wiki/images/math/0/2/c/02cda53abdf42bc294ba50e81ace4a2c.png" /> for dense graphs.
</p><p>What if the graph is sparse and it has negative edge weights? Can we do better than <img class="mwe-math-fallback-image-inline tex" alt="O(V^3)" src="/wiki/images/math/0/2/c/02cda53abdf42bc294ba50e81ace4a2c.png" /> here? Not using the Bellman–Ford algorithm <img class="mwe-math-fallback-image-inline tex" alt="V" src="/wiki/images/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png" /> times, certainly. However, it turns out that it is possible to run Bellman–Ford <i>once</i> and thus transform the graph into a form in which all edge weights are nonnegative, then run Dijkstra's <img class="mwe-math-fallback-image-inline tex" alt="V" src="/wiki/images/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png" /> times. This gives a method known as <a href="/wiki/Johnson%27s_algorithm" title="Johnson's algorithm">Johnson's algorithm</a> that matches the time bound for graphs with nonnegative edge weights (since the time taken to run Bellman–Ford is asymptotically dominated by the time taken to run <img class="mwe-math-fallback-image-inline tex" alt="V" src="/wiki/images/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png" /> invocations of Dijkstra's).
</p>
<h2><span class="mw-headline" id="Single-pair_shortest_path">Single-pair shortest path</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Shortest_path&amp;action=edit&amp;section=6" title="Edit section: Single-pair shortest path">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>We can compute a single-pair shortest path by taking the source <img class="mwe-math-fallback-image-inline tex" alt="s" src="/wiki/images/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png" /> and running single-source shortest paths from it, and simply extracting the shortest path to the destination <img class="mwe-math-fallback-image-inline tex" alt="t" src="/wiki/images/math/e/3/5/e358efa489f58062f10dd7316b65649e.png" />. This computes a lot of extra information (namely, the shortest paths to all the other vertices as well), so we might wonder whether it is possible to do better. It turns out that there are no known single-pair shortest path algorithms that outperform single-source shortest paths algorithms <i>in the worst case</i>. Nevertheless, it is often possible to do better in the <i>average case</i>.
</p><p>(Note: if edges of negative weight are allowed to exist in an infinite graph, then the problem is impossible; if any bound on the running time to find a shortest path is claimed, we can defeat this claim by constructing a graph in which the shortest path involves a highly negatively weighted edge that is extremely far away, too far to be explored within the time bound.)
</p>
<h3><span class="mw-headline" id="A.2A_or_heuristic_search">A* or heuristic search</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Shortest_path&amp;action=edit&amp;section=7" title="Edit section: A* or heuristic search">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In the single-pair shortest path problem, we know exactly where we want to go, we just don't know how to get there. But what if we were able to guess roughly how far away we are from the destination? Then we could proceed as in Dijkstra's algorithm, but give priority to exploring edges that we think take us closer to the destination rather than further away. Formally, we define a <i>heuristic function</i> <img class="mwe-math-fallback-image-inline tex" alt="h:V \to \mathbb{R}" src="/wiki/images/math/4/1/f/41fbbd056a83a52f79378e89d4fffe0b.png" /> such that <img class="mwe-math-fallback-image-inline tex" alt="h(v)" src="/wiki/images/math/2/9/f/29fa341538b830068f3fb71958032e0f.png" /> is a "guess" for the actual distance between <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> and <img class="mwe-math-fallback-image-inline tex" alt="t" src="/wiki/images/math/e/3/5/e358efa489f58062f10dd7316b65649e.png" /> (the destination). If we can find such a heuristic function that never <i>overestimates</i> (only underestimates) the correct distance, we can use the <a href="/wiki/index.php?title=A*_search_algorithm&amp;action=edit&amp;redlink=1" class="new" title="A* search algorithm (page does not exist)">A* search algorithm</a> to take advantage of this information to help find a shortest path more quickly. (If <img class="mwe-math-fallback-image-inline tex" alt="h" src="/wiki/images/math/2/5/1/2510c39011c5be704182423e3a695e91.png" /> overestimates, then we may still get a relatively short path, but we are not guaranteed that it is a correct shortest path.) The better our estimates with <img class="mwe-math-fallback-image-inline tex" alt="h" src="/wiki/images/math/2/5/1/2510c39011c5be704182423e3a695e91.png" />, the faster the search, but in the worst case, in which our heuristic is totally off, we cannot improve much over Dijkstra's.
</p>
<h3><span class="mw-headline" id="Meet-in-the-middle">Meet-in-the-middle</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Shortest_path&amp;action=edit&amp;section=8" title="Edit section: Meet-in-the-middle">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Another example of when we don't have to worry much about the worst case, and hence might be able to get a better search time, is when the graph we are searching is extremely large but yet we know that the shortest path is relatively short. For example, consider the Rubik's cube graph, in which each legal position is a vertex and an edge exists between two vertices if the positions they represent can be interconverted with one face turn. There are approximately <img class="mwe-math-fallback-image-inline tex" alt="4.3\times10^{19}" src="/wiki/images/math/4/9/7/497984677646f0746c2df665a39456cc.png" /> positions of the Rubik's cube, but the shortest path between any pair of vertices always has length 20 or less.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[1]</a></sup> The graph we are searching may even be infinite.
</p><p>Meet-in-the-middle search works similarly to a single-source search such as BFS or Djikstra's algorithm, but it differs in that the algorithm branches outward from both the source and the destination (<i>backward</i> along directed edges, if any). In this way we simultaneously build the beginning of the path (by searching from the source) and the end (by searching from the destination). When a common vertex is reached, these two pieces of the path may be assembled to form the full path. To understand why this is faster, imagine we were to execute BFS on the Rubik's Cube graph in order to try to find a path from a scrambled position to the solved position. Each vertex in the graph has degree 18 (three possible moves per face), so, if the distance from the scrambled position to the solved position is, say, 8, we will visit on the order of 18<sup>8</sup> vertices in the search (about 11 billion). If on the other hand we found this path by finding a path of length 4 from the source and a path of length 4 from the destination that happened to share an endpoint, we would only visit on the order of 2&#215;18<sup>4</sup> vertices, which is about 210000. So we have cut down the size of the part of the graph we have to explore by a factor of about 50000. Note however that there is no free lunch; we need some way of determining when a vertex has been visited both forward and backward, such as a hash table.
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Shortest_path&amp;action=edit&amp;section=9" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><a href="#cite_ref-1">↑</a></span> <span class="reference-text">Tomas Rokicki <i>et al.</i> "God's Number is 20". Retrieved 2011-03-02 from <a rel="nofollow" class="external free" href="http://cube20.org/">http://cube20.org/</a></span>
</li>
</ol>

<!-- 
NewPP limit report
CPU time usage: 0.119 seconds
Real time usage: 0.135 seconds
Preprocessor visited node count: 1051/1000000
Preprocessor generated node count: 2334/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:117-0!*!0!!en!*!*!math=0 and timestamp 20180417130929 and revision id 1329
 -->
</div>									<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://wcipeg.com/wiki/index.php?title=Shortest_path&amp;oldid=1329">https://wcipeg.com/wiki/index.php?title=Shortest_path&amp;oldid=1329</a>"					</div>
													<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-createaccount"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Shortest+path&amp;type=signup" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li><li id="pt-login"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Shortest+path" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
															<li  id="ca-nstab-main" class="selected"><span><a href="/wiki/Shortest_path"  title="View the content page [c]" accesskey="c">Page</a></span></li>
															<li  id="ca-talk" class="new"><span><a href="/wiki/index.php?title=Talk:Shortest_path&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a href="/wiki/Shortest_path" >Read</a></span></li>
															<li id="ca-edit"><span><a href="/wiki/index.php?title=Shortest_path&amp;action=edit"  title="You can edit this page. Please use the preview button before saving [e]" accesskey="e">Edit</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="/wiki/index.php?title=Shortest_path&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>

						<form action="/wiki/index.php" id="searchform">
														<div id="simpleSearch">
															<input type="search" name="search" placeholder="Search" title="Search PEGWiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />								</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="/wiki/Main_Page"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
			<h3 id='p-navigation-label'>Navigation</h3>

			<div class="body">
									<ul>
													<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
													<li id="n-Index"><a href="/wiki/Special:AllPages">Index</a></li>
													<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
													<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
													<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
			<h3 id='p-tb-label'>Tools</h3>

			<div class="body">
									<ul>
													<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Shortest_path" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
													<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Shortest_path" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
													<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
													<li id="t-print"><a href="/wiki/index.php?title=Shortest_path&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
													<li id="t-permalink"><a href="/wiki/index.php?title=Shortest_path&amp;oldid=1329" title="Permanent link to this revision of the page">Permanent link</a></li>
													<li id="t-info"><a href="/wiki/index.php?title=Shortest_path&amp;action=info" title="More information about this page">Page information</a></li>
											</ul>
							</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 26 May 2011, at 07:09.</li>
											<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by/3.0/">Attribution 3.0 Unported</a> unless otherwise noted.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="/wiki/PEGWiki:Privacy_policy" title="PEGWiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/wiki/PEGWiki:About" title="PEGWiki:About">About PEGWiki</a></li>
											<li id="footer-places-disclaimer"><a href="/wiki/PEGWiki:General_disclaimer" title="PEGWiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
															<a href="http://creativecommons.org/licenses/by/3.0/"><img src="http://i.creativecommons.org/l/by/3.0/88x31.png" alt="Attribution 3.0 Unported" width="88" height="31" /></a>
													</li>
											<li id="footer-poweredbyico">
															<a href="//www.mediawiki.org/"><img src="/wiki/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/wiki/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /wiki/resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" /></a>
													</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>if(window.jQuery)jQuery.ready();</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["ext.cite","mediawiki.toc","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"https://wcipeg.com/wiki/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=vector\u0026amp;*\"\u003E\u003C/script\u003E");
}</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":76});
}</script>
	</body>
</html>
