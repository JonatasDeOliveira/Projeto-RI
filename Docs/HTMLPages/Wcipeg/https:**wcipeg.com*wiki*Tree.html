<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" />
<title>Tree - PEGWiki</title>
<meta name="generator" content="MediaWiki 1.25.2" />
<link rel="alternate" type="application/x-wiki" title="Edit" href="/wiki/index.php?title=Tree&amp;action=edit" />
<link rel="edit" title="Edit" href="/wiki/index.php?title=Tree&amp;action=edit" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/wiki/opensearch_desc.php" title="PEGWiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://wcipeg.com/wiki/api.php?action=rsd" />
<link rel="alternate" hreflang="x-default" href="/wiki/Tree" />
<link rel="copyright" href="http://creativecommons.org/licenses/by/3.0/" />
<link rel="alternate" type="application/atom+xml" title="PEGWiki Atom feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=ext.math.styles%7Cext.rtlcite%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wikidb:resourceloader:filter:minify-css:7:b36fd1c042133c9c9b60260f7c29b237 */</style>
<script src="https://wcipeg.com/wiki/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Tree","wgTitle":"Tree","wgCurRevisionId":1490,"wgRevisionId":1490,"wgArticleId":171,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Graph theory","Pages needing diagrams","Trees"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Tree","wgRelevantArticleId":171,"wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});});
/* cache key: wikidb:resourceloader:filter:minify-js:7:a5c52c063dc436c1ca7c9f456936a5e9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/wiki/skins/Vector/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Tree skin-vector action-view">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

						<div class="mw-indicators">
</div>
			<h1 id="firstHeading" class="firstHeading" lang="en">Tree</h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">From PEGWiki</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>A <b>tree</b> is a connected, acyclic, undirected <a href="/wiki/Graph" title="Graph" class="mw-redirect">graph</a>. Trees are named for their resemblance to the eponymous tall, woody plants, as these are also connected and acyclic (a tree is in one piece, but its branches never form cycles). A collection of disjoint trees is known as a <b>forest</b>.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Characterization"><span class="tocnumber">1</span> <span class="toctext">Characterization</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Anatomy"><span class="tocnumber">2</span> <span class="toctext">Anatomy</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Tree_traversal"><span class="tocnumber">3</span> <span class="toctext">Tree traversal</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Binary_and_k-ary_trees"><span class="tocnumber">4</span> <span class="toctext">Binary and <i>k</i>-ary trees</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Inorder_traversal"><span class="tocnumber">4.1</span> <span class="toctext">Inorder traversal</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Tree_data_structures"><span class="tocnumber">5</span> <span class="toctext">Tree data structures</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Tree_problems"><span class="tocnumber">6</span> <span class="toctext">Tree problems</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#References"><span class="tocnumber">7</span> <span class="toctext">References</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Characterization">Characterization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Tree&amp;action=edit&amp;section=1" title="Edit section: Characterization">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>For a simple graph, any two of these three statements, taken together, imply the third (<a href="/wiki/Tree/Proof_of_properties_of_trees" title="Tree/Proof of properties of trees">proof</a>):
</p>
<ul><li> The graph is connected.</li>
<li> The graph is acyclic.</li>
<li> The number of vertices in the graph is exactly one more than the number of edges.</li></ul>
<p>This implies that when two of these conditions are known to hold, the graph is definitely a tree, and that all trees satisfy all three conditions (with the exception of the empty tree, which contains no nodes at all, and is sometimes considered not to be a valid tree anyway).
</p><p>Additionally, the statement that there is exactly one path between any pair of vertices is also equivalent to the statement that the graph is a tree.
</p><p>All trees are planar, but not all planar graphs are trees.
</p>
<h2><span class="mw-headline" id="Anatomy">Anatomy</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Tree&amp;action=edit&amp;section=2" title="Edit section: Anatomy">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Some trees are <b>rooted</b>, that is, they have one particular vertex designated the <b>root</b>. Others are <b>unrooted</b>, perhaps because no significance can be attached to singling out one vertex to be a root. Here are examples, that serve to introduce and explain terminology:
</p>
<ul><li> In an organic tree, there are several points at which the trunk and its branches divide. Let these, along with the ground, and the endpoints of the smallest branches, be vertices, with the vertex at the ground being labelled the root, for obvious reasons, and let the trunk and branches be the edges. The significance of the rooting is that the trunk and all its branches are considered to emanate from the root (which makes sense given how trees actually grow). The vertices corresponding to the endpoints of the smallest branches, which always have degree one, are called <b>leaves</b>, in strict analogy. The distance from the root node to any other node is sometimes called that node's <b>height</b>, again in strict analogy, but, due to the practice in computer science of drawing trees upside-down, it is more commonly called the <b>depth</b>. The maximum height of any node in the tree is known as the tree's height.</li>
<li> The <i>family tree</i> consisting of all descendants of an individual: This, too, is named for its resemblance to an organic tree, and it is no surprise that it can be placed into analogy with a graph-theoretic tree as well. Let each person in the family tree be a vertex and let there be an edge between two vertices if one of the corresponding individuals is a child of the other. Label the vertex corresponding to the aforementioned individual as the root vertex. Then, all adjacent vertices represent that individual's child, and, in strict analogy, these nodes are said to be <b>children</b> of the root node. In general, in a rooted tree, if two nodes are adjacent, the one further away from the root is considered to be a child of the one closer, and the one closer is called the <b>parent</b> of the one further away. (A node will always have exactly one parent, unless it is the root.) Furthermore, given some node <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />, the node itself, its children, its children's children, and so on, are called the node's <b>descendants</b>; the term <i>proper descendant</i> is sometimes taken to mean the same but excluding <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> itself. Likewise, <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />, <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />'s parent, <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />'s parent's parent, and so on, are called <b>ancestors</b> (with the term <i>proper ancestor</i> being defined analogously). The root is ancestral to all nodes.</li>
<li> In the <i>tree of life</i>, each vertex represents a species and edges represent evolution of one species into another. The root of this tree is some universal common ancestor of life on Earth, and the leaves of this tree are either extant species or species that have gone extinct without radiating or transitioning to a newer species.</li>
<li> A corporate hierarchy can theoretically be represented by a rooted tree, where each employee is a vertex and a vertex's children are those vertices corresponding to the employees managed by subordinates, and the vertex corresponding to the CEO (or equivalent) is the root of the tree. Hierarchies in general are easily representable by trees.</li>
<li> Given some initially disconnected cities, we might wish to build some roads between pairs of cities such that there is exactly one path between any pair of cities; having fewer than one would imply that some cities are not reachable from each other, and having more than one would introduce redundancies. So we build roads in such a way that the cities are vertices and the roads edges of a tree. This is an example of an unrooted tree because there is no specific reason why any node should be labelled the root.</li>
<li> When a pair of parallel, closely spaced wooden boards with some nails hammered into them is immersed in a solution of water, soap, and glycerin, and then removed, a soap film will be formed that connects all the nails together without forming any cycles <a rel="nofollow" class="external autonumber" href="http://cgg-journal.com/2001-2/01/CFIG14.gif">[1]</a>. This gives what is called a <i>Steiner tree</i>. Again, this is an unrooted tree, as it makes no sense to label any particular vertex the root.</li></ul>
<p>The distinction between rooted and unrooted trees is somewhat artificial; we can always convert a rooted tree to an unrooted tree by forgetting which node is the root, and we may sometimes wish, in algorithms, to regard an unrooted tree as rooted by arbitrarily choosing a root.
</p><p>Note that in a rooted tree, the root is not considered to be a leaf even when it has degree one (unless it actually has no children, which occurs only when it is the only node in the tree). On the other hand, in an unrooted tree, any node with degree one is considered a leaf.
</p><p>Any connected subgraph of a tree is itself a tree and is called a <b>subtree</b> of that tree, but in a rooted tree, the term is usually used in a restricted sense to denote a node <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> plus all of its descendants; this is referred to as <i>the subtree rooted at <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /></i>. (The subtree rooted at the root is the tree itself.) We shall use the term in this restricted sense throughout this article. A subtree can correspond to, in the examples above, everything emanating from a specific branch of an organic tree, or all the descendants of one particular individual, or a clade (monophyletic taxon), or all the employees subject to a particular employee's authority.
</p>
<h2><span class="mw-headline" id="Tree_traversal">Tree traversal</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Tree&amp;action=edit&amp;section=3" title="Edit section: Tree traversal">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Tree <b>traversal</b> is the act of visiting every vertex of a tree. Traversing a tree produces an ordering of the tree's vertices. If a tree has <img class="mwe-math-fallback-image-inline tex" alt="N" src="/wiki/images/math/8/d/9/8d9c307cb7f3c4a32822a51922d1ceaa.png" /> nodes, then there are <img class="mwe-math-fallback-image-inline tex" alt="N!" src="/wiki/images/math/3/e/9/3e90a418f96ec0edccf92cedc72422ca.png" /> different orderings, but two are particularly important: <b>preorder</b> and <b>postorder</b>. In a preorder traversal, we perform a <a href="/wiki/Depth-first_search" title="Depth-first search">depth-first search</a> starting from the tree's root, and a node is considered to be visited as soon as it is first pushed onto the stack. A postorder traversal is similar, but now a node is considered to be visited only after all its children have been visited. (Leaf nodes are still considered visited as soon as they are pushed on the stack, as they have no children.) In some trees, an order is already imposed on the children of any given vertex; that is, a node with multiple children has a well-defined first child, second child, and so on. In these case, preorder and postorder traversals always visit a node's children in order, and are unique for a given rooted tree.
</p>
<h2><span class="mw-headline" id="Binary_and_k-ary_trees">Binary and <i>k</i>-ary trees</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Tree&amp;action=edit&amp;section=4" title="Edit section: Binary and k-ary trees">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A <b>binary tree</b> is a rooted tree in which every vertex has at most two children, called <i>left</i> and <i>right</i>. The subtree rooted at a node's left child is called the <i>left subtree</i>, with <i>right subtree</i> defined analogously. Binary trees are of special interest because of their ability to organize data, as in <a href="/wiki/index.php?title=Binary_search_tree&amp;action=edit&amp;redlink=1" class="new" title="Binary search tree (page does not exist)">binary search trees</a> and <a href="/wiki/Binary_heap" title="Binary heap">binary heaps</a>.
</p><p>A binary tree is regarded as having an infinite number of <i>levels</i>, only finitely many of which are usually filled. A level consists of all nodes of a given depth. The zeroth level consists of only the root; the first level consists of the root's children, that is, the potential nodes of depth one, of which there are at most two; the second level consists of all of the root's potential grandchildren, that is, the potential nodes of depth two, of which there are at most four, and so on; in general, level <img class="mwe-math-fallback-image-inline tex" alt="h" src="/wiki/images/math/2/5/1/2510c39011c5be704182423e3a695e91.png" /> can contain up to <img class="mwe-math-fallback-image-inline tex" alt="2^h" src="/wiki/images/math/c/d/f/cdff5e8c7c72e167a0ba493190017834.png" /> nodes. If a binary tree has height <img class="mwe-math-fallback-image-inline tex" alt="h" src="/wiki/images/math/2/5/1/2510c39011c5be704182423e3a695e91.png" />, then the maximum number of nodes it might contain is then <img class="mwe-math-fallback-image-inline tex" alt="1 + 2 + 4 + ... + 2^h = 2^{h+1}-1" src="/wiki/images/math/e/3/5/e35cad9c7a8a33e1a2888d255c26d68f.png" />. Likewise, a binary tree containing <img class="mwe-math-fallback-image-inline tex" alt="N" src="/wiki/images/math/8/d/9/8d9c307cb7f3c4a32822a51922d1ceaa.png" /> nodes has height at least <img class="mwe-math-fallback-image-inline tex" alt="\lceil \log_2(N+1) \rceil - 1" src="/wiki/images/math/5/6/3/5636641f2aa7ec77d4491c27cb47f40f.png" />.
</p><p>There is some variation in the relationship between the terms <b>leaf</b>, <b>internal node</b>, and <b>external node</b>. Here are three possibilities:
</p>
<ul><li> All nodes in the binary tree are considered <i>internal nodes</i>, with the <i>leaves</i> being the internal nodes that have zero children. If an internal node has fewer than two children, the children it <i>might</i> have had are designated <i>external nodes</i>. The external nodes are not actually part of the tree.</li>
<li> All nodes in the binary tree are considered <i>internal nodes</i>. If an internal node has fewer than two children, the children it <i>might</i> have had are designated <i>external nodes</i>, also known as <i>leaves</i>.</li>
<li> All nodes in the binary tree must have either zero or two children. The nodes that have two children are called <i>internal nodes</i>, whereas those that have zero children are called <i>leaves</i> or <i>external nodes</i>.</li></ul>
<p>These three conventions are really only different ways of labelling nodes, but the fact that all three are in use can be confusing. The reason why different conventions exist is probably that, in some applications, only the internal nodes are meaningful, whereas in others, the external nodes are sentinels, and in others still, data are stored only in leaves. The first convention is the one used in <a href="/wiki/index.php?title=ACSL&amp;action=edit&amp;redlink=1" class="new" title="ACSL (page does not exist)">ACSL</a> Short Questions and the one we shall use in this article.
</p><p>It can be proven inductively that the number of external nodes in a tree is always one more than the number of internal nodes. The <b>internal path length</b> of a binary tree is the sum of the lengths of the paths from the root to all other internal nodes; it is not hard to see that this is also equal to the sum of the depths of all the internal nodes in the tree. The <b>external path length</b> is analogously defined. It can be proven inductively that <img class="mwe-math-fallback-image-inline tex" alt="E = I + 2N" src="/wiki/images/math/6/9/3/69395ff8e0ab5863eae03b95981ac606.png" />, where <img class="mwe-math-fallback-image-inline tex" alt="I" src="/wiki/images/math/d/d/7/dd7536794b63bf90eccfd37f9b147d7f.png" /> is the internal path length, <img class="mwe-math-fallback-image-inline tex" alt="E" src="/wiki/images/math/3/a/3/3a3ea00cfc35332cedf6e5e9a32e94da.png" /> is the external path length, and <img class="mwe-math-fallback-image-inline tex" alt="N" src="/wiki/images/math/8/d/9/8d9c307cb7f3c4a32822a51922d1ceaa.png" /> is the number of internal nodes.
</p><p>A binary tree is said to be <b>complete</b> when levels 0 through <img class="mwe-math-fallback-image-inline tex" alt="h-1" src="/wiki/images/math/d/1/d/d1d41106630da1ee4622057722ce14b6.png" /> are completely filled, and all nodes on level <img class="mwe-math-fallback-image-inline tex" alt="h" src="/wiki/images/math/2/5/1/2510c39011c5be704182423e3a695e91.png" /> are as far to the left as possible. A complete binary tree will always have the minimum height possible. A binary tree is said to be <b>balanced</b> when all external nodes have similar height; if the heights of any two external nodes differ by at most one, it is said to be <b>perfectly balanced</b>. Balanced trees are useful for searching efficiently.
</p><p>A <i>k</i>-ary tree is a rooted tree in which every vertex has at most <img class="mwe-math-fallback-image-inline tex" alt="k" src="/wiki/images/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png" /> children. Similar terminology applies.
</p>
<h3><span class="mw-headline" id="Inorder_traversal">Inorder traversal</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Tree&amp;action=edit&amp;section=5" title="Edit section: Inorder traversal">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In addition to preorder and postorder, a binary tree has an <b>inorder</b> traversal, in which a node is considered to be visited after its left subtree, if any, has been completely explored, but before its right child has been pushed onto the stack. The inorder traversal is unique for a given binary tree, and inorder traversal of a binary search tree always gives a sorted list.
</p>
<h2><span class="mw-headline" id="Tree_data_structures">Tree data structures</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Tree&amp;action=edit&amp;section=6" title="Edit section: Tree data structures">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following data structures are based on rooted trees, often binary trees:
</p>
<ul><li> <a href="/wiki/index.php?title=Binary_search_tree&amp;action=edit&amp;redlink=1" class="new" title="Binary search tree (page does not exist)">Binary search tree</a>: The label of a node is always at least as large as that of its left child, if any, and smaller than that of its right child, if any. Binary search trees enable efficient implementations of <a href="/wiki/index.php?title=Dictionaries&amp;action=edit&amp;redlink=1" class="new" title="Dictionaries (page does not exist)">dictionaries</a>.</li></ul>
<dl><dd><ul><li> <a href="/wiki/index.php?title=2-3_tree&amp;action=edit&amp;redlink=1" class="new" title="2-3 tree (page does not exist)">2-3 trees</a>, <a href="/wiki/index.php?title=2-3-4_tree&amp;action=edit&amp;redlink=1" class="new" title="2-3-4 tree (page does not exist)">2-3-4 trees</a>, and <a href="/wiki/index.php?title=B-trees&amp;action=edit&amp;redlink=1" class="new" title="B-trees (page does not exist)">B-trees</a> are similar, but nodes in these trees may have more than two children.</li></ul></dd></dl>
<ul><li> <a href="/wiki/Binary_heap" title="Binary heap">Binary heap</a>: A complete binary tree in which the label of each node is always at least as large as that of both of its children, if any.</li></ul>
<dl><dd><ul><li> The <a href="/wiki/Binomial_heap" title="Binomial heap">binomial heap</a> is a variation on the binary heap that preserves its efficiency while also enabling heaps to be efficiently merged.</li>
<li> The <a href="/wiki/index.php?title=Fibonacci_heap&amp;action=edit&amp;redlink=1" class="new" title="Fibonacci heap (page does not exist)">Fibonacci heap</a> is a variation on the binary heap that, in amortized analysis, is even faster than the binomial heap in most operations.</li></ul></dd></dl>
<ul><li> <a href="/wiki/Segment_tree" title="Segment tree">Segment tree</a>, <i>range tree</i>, or <i>interval tree</i>: A binary tree representing an <a href="/wiki/Array" title="Array">array</a> in which leaf nodes represent individual elements of the array and the datum stored in each non-leaf node is an associative binary function of the data stored in its children. Segment trees enable efficient dynamic computation of associative functions on segments of the array.</li>
<li> <a href="/wiki/index.php?title=Binary_indexed_tree&amp;action=edit&amp;redlink=1" class="new" title="Binary indexed tree (page does not exist)">Binary indexed tree</a> (BIT) or <i>Fenwick tree</i>: Similar to a segment tree, but enables efficient dynamic computation of associative functions only on <i>prefixes</i> of the array. Nevertheless, if the function and the elements of the array form a group structure, inclusion-exclusion allows efficient queries on non-initial segments too.</li>
<li> <a href="/wiki/index.php?title=Parse_tree&amp;action=edit&amp;redlink=1" class="new" title="Parse tree (page does not exist)">Parse tree</a>: The tree that results from parsing a <a href="/wiki/String" title="String">string</a>. A parse tree has <i>symbols</i>, that is, atomic sequences of characters, in its leaves, and traversing the tree left-to-right and concatenating all the symbols gives the original string. Each subtree of a parse tree represents a substring and non-leaf nodes carry information about the syntactic relationship between the substrings represented by the subtrees rooted at their immediate children.</li>
<li> <a href="/wiki/index.php?title=Abstract_syntax_tree&amp;action=edit&amp;redlink=1" class="new" title="Abstract syntax tree (page does not exist)">Abstract syntax tree</a>: An abstract syntax tree (AST) is similar to a parse tree, but it carries abstract information about the parsed string rather than concrete information. Its leaves are then elementary <i>concepts</i> and the internal nodes encode <i>logical</i> rather than syntactic relationships (which might be called <i>meaning</i>).</li>
<li> A <a href="/wiki/index.php?title=Kd-tree&amp;action=edit&amp;redlink=1" class="new" title="Kd-tree (page does not exist)">kd-tree</a> stores <img class="mwe-math-fallback-image-inline tex" alt="k" src="/wiki/images/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png" />-dimensional points in a way that enables efficient solution of nearest-neighbor search and other problems.</li>
<li> A <a href="/wiki/index.php?title=Trie&amp;action=edit&amp;redlink=1" class="new" title="Trie (page does not exist)">trie</a> or <i>prefix tree</i> is a tree in which every node contains a character and every path from root to internal node spells out a prefix. Tries are useful for organizing strings.</li>
<li> A <a href="/wiki/index.php?title=Suffix_tree&amp;action=edit&amp;redlink=1" class="new" title="Suffix tree (page does not exist)">suffix tree</a> is similar to a prefix tree, but paths now spell out suffixes rather than prefixes. Suffix trees enable efficient solutions to many important string problems, but are very difficult to construct.</li>
<li> The <a href="/wiki/index.php?title=Link/cut_tree&amp;action=edit&amp;redlink=1" class="new" title="Link/cut tree (page does not exist)">link/cut tree</a>, a data structure devised by Sleator and Tarjan, supports efficient queries on a dynamic weighted forest, and gives fast solutions to the <a href="/wiki/Maximum_flow" title="Maximum flow">maximum flow</a> problem.</li></ul>
<h2><span class="mw-headline" id="Tree_problems">Tree problems</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Tree&amp;action=edit&amp;section=7" title="Edit section: Tree problems">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following are problems involving trees, or problems involving graphs that have more efficient or elegant solutions when trees are involved.
</p>
<ul><li> <b><a href="/wiki/Minimum_spanning_tree" title="Minimum spanning tree">Minimum spanning tree</a> problem</b>: A tree <img class="mwe-math-fallback-image-inline tex" alt="T" src="/wiki/images/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png" /> is said to <b>span</b> a graph <img class="mwe-math-fallback-image-inline tex" alt="G" src="/wiki/images/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png" /> when <img class="mwe-math-fallback-image-inline tex" alt="T" src="/wiki/images/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png" /> is a subgraph of <img class="mwe-math-fallback-image-inline tex" alt="G" src="/wiki/images/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png" /> that contains all of <img class="mwe-math-fallback-image-inline tex" alt="G" src="/wiki/images/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png" />'s vertices. The weight of a tree is the sum of the weights of its edges. Find a spanning tree of minimum weight.</li></ul>
<dl><dd><ul><li> <b><a href="/wiki/index.php?title=Minimum_diameter_spanning_tree&amp;action=edit&amp;redlink=1" class="new" title="Minimum diameter spanning tree (page does not exist)">Minimum diameter spanning tree</a> problem</b>: Similar, but now we want a spanning tree with minimum diameter.</li>
<li> Spanning trees also arise incidentally when a <a href="/wiki/Graph_search" title="Graph search">graph search</a>, such as <a href="/wiki/Depth-first_search" title="Depth-first search">depth-first search</a> or <a href="/wiki/Breadth-first_search" title="Breadth-first search">breadth-first search</a> is performed, giving a <i>DFS tree</i> or <i>BFS tree</i>, respectively. Performing <a href="/wiki/Dijkstra%27s_algorithm" title="Dijkstra's algorithm">Dijkstra's algorithm</a>, effectively a priority-first search, gives a <i>shortest paths tree</i>.</li></ul></dd></dl>
<ul><li> <b><a href="/wiki/Lowest_common_ancestor" title="Lowest common ancestor">Lowest common ancestor</a> (LCA) problem</b>: Given a pair of nodes in a tree, efficiently determine their lowest common ancestor, that is, the deepest node that is an ancestor of both given nodes. A variety of algorithms exist for this important problem.</li>
<li> It is easy to find the <i>distance</i> between any pair of nodes in a tree, weighted or unweighted, because there is only one path to consider, which may be found using depth-first search or breadth-first search.</li></ul>
<dl><dd><ul><li> To find the <i>diameter</i> of a tree, pick any starting vertex <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" />, find the vertex <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> furthest away from <img class="mwe-math-fallback-image-inline tex" alt="u" src="/wiki/images/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png" /> using DFS or BFS (breaking ties arbitrarily), and then find the vertex <img class="mwe-math-fallback-image-inline tex" alt="w" src="/wiki/images/math/f/1/2/f1290186a5d0b1ceab27f4e77c0c5d68.png" /> furthest away from <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" />. The distance between <img class="mwe-math-fallback-image-inline tex" alt="v" src="/wiki/images/math/9/e/3/9e3669d19b675bd57058fd4664205d2a.png" /> and <img class="mwe-math-fallback-image-inline tex" alt="w" src="/wiki/images/math/f/1/2/f1290186a5d0b1ceab27f4e77c0c5d68.png" /> is the tree's diameter.<sup id="cite_ref-diameter_1-0" class="reference"><a href="#cite_note-diameter-1">[1]</a></sup></li>
<li> In the <i>dynamic distance query</i> problem, we wish to be able to efficiently determine the distances between pairs of nodes in a tree, but we also want to be able to change the weights of edges. This problem is solved using the <a href="/wiki/Heavy-light_decomposition" title="Heavy-light decomposition">heavy-light decomposition</a>.</li></ul></dd></dl>
<ul><li> The <i>maximum matching problem</i>, <i>minimum vertex cover problem</i>, <i>minimum edge cover problem</i>, and <i>maximum independent set problem</i> all admit simple <a href="/wiki/Dynamic_programming" title="Dynamic programming">dynamic programming</a> solutions when the graph involved is a tree.</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Tree&amp;action=edit&amp;section=8" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-diameter-1"><span class="mw-cite-backlink"><a href="#cite_ref-diameter_1-0">↑</a></span> <span class="reference-text">Bang Ye Wu and Kun&#8211;Mao Chao. <i>A note on Eccentricities, diameters, and radii</i>. Retrieved from <a rel="nofollow" class="external free" href="http://www.csie.ntu.edu.tw/~kmchao/tree07spr/diameter.pdf">http://www.csie.ntu.edu.tw/~kmchao/tree07spr/diameter.pdf</a></span>
</li>
</ol>

<!-- 
NewPP limit report
CPU time usage: 0.074 seconds
Real time usage: 0.081 seconds
Preprocessor visited node count: 370/1000000
Preprocessor generated node count: 826/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:171-0!*!0!!en!*!*!math=0 and timestamp 20180417181414 and revision id 1490
 -->
</div>									<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://wcipeg.com/wiki/index.php?title=Tree&amp;oldid=1490">https://wcipeg.com/wiki/index.php?title=Tree&amp;oldid=1490</a>"					</div>
													<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="/wiki/Category:Graph_theory" title="Category:Graph theory">Graph theory</a></li><li><a href="/wiki/Category:Pages_needing_diagrams" title="Category:Pages needing diagrams">Pages needing diagrams</a></li><li><a href="/wiki/Category:Trees" title="Category:Trees">Trees</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-createaccount"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Tree&amp;type=signup" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li><li id="pt-login"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Tree" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
															<li  id="ca-nstab-main" class="selected"><span><a href="/wiki/Tree"  title="View the content page [c]" accesskey="c">Page</a></span></li>
															<li  id="ca-talk"><span><a href="/wiki/Talk:Tree"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a href="/wiki/Tree" >Read</a></span></li>
															<li id="ca-edit"><span><a href="/wiki/index.php?title=Tree&amp;action=edit"  title="You can edit this page. Please use the preview button before saving [e]" accesskey="e">Edit</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="/wiki/index.php?title=Tree&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>

						<form action="/wiki/index.php" id="searchform">
														<div id="simpleSearch">
															<input type="search" name="search" placeholder="Search" title="Search PEGWiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />								</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="/wiki/Main_Page"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
			<h3 id='p-navigation-label'>Navigation</h3>

			<div class="body">
									<ul>
													<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
													<li id="n-Index"><a href="/wiki/Special:AllPages">Index</a></li>
													<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
													<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
													<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
			<h3 id='p-tb-label'>Tools</h3>

			<div class="body">
									<ul>
													<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Tree" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
													<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Tree" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
													<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
													<li id="t-print"><a href="/wiki/index.php?title=Tree&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
													<li id="t-permalink"><a href="/wiki/index.php?title=Tree&amp;oldid=1490" title="Permanent link to this revision of the page">Permanent link</a></li>
													<li id="t-info"><a href="/wiki/index.php?title=Tree&amp;action=info" title="More information about this page">Page information</a></li>
											</ul>
							</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 12 December 2011, at 03:22.</li>
											<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by/3.0/">Attribution 3.0 Unported</a> unless otherwise noted.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="/wiki/PEGWiki:Privacy_policy" title="PEGWiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/wiki/PEGWiki:About" title="PEGWiki:About">About PEGWiki</a></li>
											<li id="footer-places-disclaimer"><a href="/wiki/PEGWiki:General_disclaimer" title="PEGWiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
															<a href="http://creativecommons.org/licenses/by/3.0/"><img src="http://i.creativecommons.org/l/by/3.0/88x31.png" alt="Attribution 3.0 Unported" width="88" height="31" /></a>
													</li>
											<li id="footer-poweredbyico">
															<a href="//www.mediawiki.org/"><img src="/wiki/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/wiki/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /wiki/resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" /></a>
													</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>if(window.jQuery)jQuery.ready();</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["ext.cite","mediawiki.toc","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"https://wcipeg.com/wiki/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=vector\u0026amp;*\"\u003E\u003C/script\u003E");
}</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":70});
}</script>
	</body>
</html>
